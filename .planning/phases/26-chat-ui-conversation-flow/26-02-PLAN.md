---
phase: 26-chat-ui-conversation-flow
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/app/api/ai/generate/route.ts
  - src/components/ai-wizard/steps/ChatStep.tsx
  - src/components/ai-wizard/ChatMessage.tsx
  - src/components/ai-wizard/ChatInput.tsx
  - src/components/ai-wizard/TypingIndicator.tsx
autonomous: true

must_haves:
  truths:
    - "User can send messages to AI and receive streaming responses"
    - "Typing indicator shows during AI response generation"
    - "User can cancel during streaming without losing conversation"
    - "Errors display with retry option, preserving context"
    - "Form type and audience context reaches the AI"
  artifacts:
    - path: "src/components/ai-wizard/steps/ChatStep.tsx"
      provides: "Chat conversation UI with streaming"
      min_lines: 80
    - path: "src/components/ai-wizard/ChatMessage.tsx"
      provides: "Individual message rendering"
      min_lines: 25
    - path: "src/components/ai-wizard/ChatInput.tsx"
      provides: "Message input with submit"
      min_lines: 30
    - path: "src/components/ai-wizard/TypingIndicator.tsx"
      provides: "Animated typing dots"
      min_lines: 20
    - path: "src/app/api/ai/generate/route.ts"
      provides: "API route with structured context"
      contains: "formType"
  key_links:
    - from: "ChatStep.tsx"
      to: "/api/ai/generate"
      via: "useChat hook"
      pattern: "useChat.*api.*ai/generate"
    - from: "route.ts"
      to: "system-prompt.ts"
      via: "contextual prompt building"
      pattern: "formType.*audience"
---

<objective>
Implement the chat interface with AI SDK useChat hook, streaming responses, and error handling.

Purpose: Create the conversational layer where users describe their form needs and AI responds with clarifying questions. The structured context (form type, audience) from Plan 01 is passed to the AI for better generation.

Output: Chat UI components and updated API route that incorporates structured context.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-chat-ui-conversation-flow/26-RESEARCH.md
@.planning/phases/26-chat-ui-conversation-flow/26-01-SUMMARY.md

# Phase 25 infrastructure
@src/app/api/ai/generate/route.ts
@src/lib/ai/system-prompt.ts
@src/lib/ai/error-handling.ts

# Wizard container from Plan 01
@src/components/ai-wizard/AIFormWizard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update API Route for Structured Context</name>
  <files>
    src/app/api/ai/generate/route.ts
  </files>
  <action>
Update the API route to incorporate form type and audience in the system prompt.

**Changes to route.ts:**
1. Extract `formType` and `audience` from request body alongside `messages` and `apiKey`
2. Create helper function `buildContextualPrompt(formType, audience)` that:
   - Starts with base FORM_CREATION_SYSTEM_PROMPT
   - Appends "## Current Form Request Context" section with:
     - Form Type: {formType}
     - Target Audience: {audience === 'external' ? 'External/Public' : 'Internal/Team'}
   - Appends guidance based on form type:
     - application: Ask about position/opportunity, required info, deadline
     - feedback: Ask about feedback subject, anonymity, rating aspects
     - registration: Ask about event/program, registrant details, capacity
     - survey: Ask about survey purpose, question types, length
     - other: Ask about main purpose, info to collect, target audience
   - Includes instruction: "Ask 2-3 clarifying questions maximum before generating the form."
3. Pass `buildContextualPrompt(formType, audience)` to streamText system parameter instead of raw FORM_CREATION_SYSTEM_PROMPT
4. Handle missing formType/audience gracefully (use defaults or FORM_CREATION_SYSTEM_PROMPT as fallback)

**Why:** HYB-03 requires structured selections to inform AI context. HYB-04 requires limiting to 2-3 clarifying questions.
  </action>
  <verify>
    `pnpm build` passes. API route still exports POST function. System prompt includes formType/audience when provided.
  </verify>
  <done>
    API route builds contextual system prompt incorporating form type and audience selections. AI receives guidance to ask 2-3 clarifying questions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Chat UI Components</name>
  <files>
    src/components/ai-wizard/steps/ChatStep.tsx
    src/components/ai-wizard/ChatMessage.tsx
    src/components/ai-wizard/ChatInput.tsx
    src/components/ai-wizard/TypingIndicator.tsx
  </files>
  <action>
Create the chat step and supporting components.

**TypingIndicator.tsx:**
- Import motion from 'motion/react'
- Render 3 animated dots in a muted background pill
- Animation: each dot bounces up/down with staggered delay (0.15s apart)
- Text: "AI is thinking..." next to dots
- Use Tailwind classes consistent with codebase

**ChatMessage.tsx:**
- Props: { message: UIMessage, isStreaming?: boolean }
- Import UIMessage type from 'ai'
- Determine role from message.role ('user' or 'assistant')
- Layout:
  - User messages: right-aligned, bg-primary text-primary-foreground
  - Assistant messages: left-aligned, bg-muted
  - Both: rounded-lg, px-4 py-2, max-w-[80%]
- Extract text content from message.parts (filter for type === 'text')
- If isStreaming && role === 'assistant': show blinking cursor at end

**ChatInput.tsx:**
- Props: { input: string, setInput: (v: string) => void, onSubmit: () => void, disabled: boolean, onStop?: () => void, isProcessing?: boolean }
- Layout:
  - Textarea (auto-resize, min-height 80px)
  - Button row below with Submit and optional Stop button
- Keyboard: Enter (without Shift) submits
- Submit button disabled when input empty or disabled prop true
- Stop button visible only when isProcessing is true
- Icons: Send for submit, StopCircle for stop (lucide-react)

**ChatStep.tsx:**
- Props from AIFormWizard: { messages, status, error, onSendMessage, onStop, onRegenerate, onBack, formType, audience, apiKey }
- Import useChat from '@ai-sdk/react' - NOTE: useChat is called in AIFormWizard, not here. ChatStep receives the return values as props.
- Actually, looking at research pattern, useChat SHOULD be in AIFormWizard. ChatStep receives:
  - messages: UIMessage[]
  - status: 'submitted' | 'streaming' | 'ready' | 'error'
  - error: Error | undefined
  - onSendMessage: (options: { text: string }) => void
  - onStop: () => void
  - onRegenerate: () => void
  - onBack: () => void
  - formType: string
  - audience: string
- Local state: input string
- Layout:
  - Context banner at top showing form type and audience
  - Scrollable message area (flex-1, overflow-y-auto)
  - Empty state when no messages: "Describe what you want..."
  - Map messages to ChatMessage components
  - Show TypingIndicator when status === 'submitted' or status === 'streaming' AND last message is not assistant
  - Error state below messages with retry button
  - ChatInput at bottom
- isProcessing = status === 'submitted' || status === 'streaming'
- Pass isProcessing and onStop to ChatInput for stop button visibility
  </action>
  <verify>
    `pnpm build` passes without errors. All 4 component files exist and export correctly.
  </verify>
  <done>
    Chat interface shows messages with streaming support, typing indicator during AI response, stop button during processing, and error recovery. Context banner displays form type and audience.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate useChat in AIFormWizard</name>
  <files>
    src/components/ai-wizard/AIFormWizard.tsx
  </files>
  <action>
Update AIFormWizard to include useChat hook and wire it to ChatStep.

**Changes to AIFormWizard.tsx:**
1. Import useChat from '@ai-sdk/react'
2. Import DefaultChatTransport from 'ai' (for passing body with formType/audience)
3. Import ChatStep from './steps/ChatStep'
4. Add useChat call:
```typescript
const {
  messages,
  sendMessage,
  status,
  stop,
  error,
  reload: regenerate,
} = useChat({
  api: '/api/ai/generate',
  body: {
    formType: wizard.formType,
    audience: wizard.audience,
    apiKey,
  },
});
```
5. Add conditional render for wizard.step === 'chat':
```tsx
{wizard.step === 'chat' && (
  <ChatStep
    messages={messages}
    status={status}
    error={error}
    onSendMessage={sendMessage}
    onStop={stop}
    onRegenerate={regenerate}
    onBack={handleBack}
    formType={wizard.formType!}
    audience={wizard.audience!}
  />
)}
```
6. Update handleBack to also stop() when stepping back from chat or generating states

**Note:** We're using the simpler useChat API configuration (api + body) rather than DefaultChatTransport, per AI SDK v6 patterns. The body is merged into each request.
  </action>
  <verify>
    `pnpm build` passes. AIFormWizard imports useChat and ChatStep. Chat step renders when wizard.step === 'chat'.
  </verify>
  <done>
    AIFormWizard integrates useChat hook. FormType and audience are passed in request body. ChatStep receives all necessary props for full chat functionality.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm build` completes without errors
2. API route builds contextual prompt with form type and audience
3. Chat UI shows messages, typing indicator, stop button, error state
4. AIFormWizard wires useChat to ChatStep with correct props
5. Form type and audience reach the API in request body
</verification>

<success_criteria>
- API route incorporates formType and audience into system prompt (HYB-03)
- System prompt instructs AI to ask 2-3 clarifying questions (HYB-04)
- Streaming responses show visible progress via TypingIndicator (UX-03)
- Cancel button available during generation (UX-04)
- Errors show with retry option, preserving messages (UX-05)
- Full wizard flow works: form-type -> audience -> chat
</success_criteria>

<output>
After completion, create `.planning/phases/26-chat-ui-conversation-flow/26-02-SUMMARY.md`
</output>
