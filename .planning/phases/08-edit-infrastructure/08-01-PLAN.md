---
phase: 08-edit-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/applications.ts
autonomous: true

must_haves:
  truths:
    - "editHistory table exists and accepts history records"
    - "updateField mutation atomically updates field and creates history record"
    - "getEditHistory query returns history ordered by timestamp descending"
    - "No-op edits (same value) do not create history records"
  artifacts:
    - path: "convex/schema.ts"
      provides: "editHistory table definition with indexes"
      contains: "editHistory: defineTable"
    - path: "convex/applications.ts"
      provides: "updateField mutation and getEditHistory query"
      exports: ["updateField", "getEditHistory"]
  key_links:
    - from: "convex/applications.ts (updateField)"
      to: "editHistory table"
      via: "ctx.db.insert into editHistory"
      pattern: "ctx\\.db\\.insert\\(\"editHistory\""
    - from: "convex/applications.ts (getEditHistory)"
      to: "editHistory table"
      via: "query with by_application index"
      pattern: "withIndex\\(\"by_application\""
---

<objective>
Add edit history infrastructure to Convex backend

Purpose: Enable tracking of all field changes with old/new values for the inline editing feature. This is foundational - no UI involved, just database schema and mutations.

Output: New `editHistory` table, `updateField` mutation, and `getEditHistory` query
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-edit-infrastructure/08-RESEARCH.md
@convex/schema.ts
@convex/applications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add editHistory table to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add the `editHistory` table to the Convex schema after the existing `applications` table definition:

```typescript
editHistory: defineTable({
  applicationId: v.id("applications"),
  field: v.string(),           // Technical field name: "fullName", "email", etc.
  oldValue: v.string(),        // Previous value as string
  newValue: v.string(),        // New value as string
  editedAt: v.number(),        // Unix timestamp (Date.now())
})
  .index("by_application", ["applicationId", "editedAt"])
  .index("by_application_field", ["applicationId", "field"]),
```

Key points:
- Place after `applications` table definition (before the closing `});`)
- All values stored as strings for simplicity
- `by_application` index supports history timeline queries (ordered by time)
- `by_application_field` index supports future field-specific queries
  </action>
  <verify>
Run `npx convex dev` and confirm schema pushes successfully with no errors. Check Convex dashboard shows `editHistory` table with correct fields and indexes.
  </verify>
  <done>
editHistory table exists in Convex schema with applicationId, field, oldValue, newValue, editedAt columns and both indexes created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add updateField mutation and getEditHistory query</name>
  <files>convex/applications.ts</files>
  <action>
Add two new functions to `convex/applications.ts`:

1. **updateField mutation** - Atomically updates a field and records history:

```typescript
/**
 * Update a single field on an application and record edit history
 *
 * Atomically:
 * 1. Gets current value
 * 2. Patches the application
 * 3. Inserts history record
 *
 * Returns { changed: false } if value unchanged (no history created)
 */
export const updateField = mutation({
  args: {
    id: v.id("applications"),
    field: v.string(),
    newValue: v.string(),
  },
  handler: async (ctx, args) => {
    const application = await ctx.db.get(args.id);
    if (!application) {
      throw new Error("Application not found");
    }

    // Get old value, handling undefined for optional fields
    const oldValue = String(
      (application as Record<string, unknown>)[args.field] ?? ""
    );

    // Skip if no actual change
    if (oldValue === args.newValue) {
      return { changed: false };
    }

    // Atomic: update field and insert history
    await ctx.db.patch(args.id, { [args.field]: args.newValue });
    await ctx.db.insert("editHistory", {
      applicationId: args.id,
      field: args.field,
      oldValue,
      newValue: args.newValue,
      editedAt: Date.now(),
    });

    return { changed: true };
  },
});
```

2. **getEditHistory query** - Retrieves history for an application:

```typescript
/**
 * Get edit history for an application
 *
 * Returns all edit records ordered by most recent first
 */
export const getEditHistory = query({
  args: {
    applicationId: v.id("applications"),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("editHistory")
      .withIndex("by_application", (q) =>
        q.eq("applicationId", args.applicationId)
      )
      .order("desc")
      .collect();
  },
});
```

Key points:
- Import `query` is already at top of file (with `mutation`)
- Use `Record<string, unknown>` cast to access dynamic field names
- Use `String(value ?? "")` to handle undefined optional fields
- No-op check prevents cluttering history with unchanged values
- `order("desc")` ensures most recent edits appear first
  </action>
  <verify>
1. Run `npx convex dev` - functions should sync without errors
2. In Convex dashboard, test `updateField`:
   - Use an existing application ID
   - Call: `updateField({ id: "...", field: "fullName", newValue: "Test Edit" })`
   - Should return `{ changed: true }`
3. Call `getEditHistory({ applicationId: "..." })` - should show the edit record
4. Call `updateField` with same value again - should return `{ changed: false }` and NOT create duplicate history
  </verify>
  <done>
updateField mutation atomically updates application fields and creates history records. getEditHistory query returns edit history ordered by timestamp descending. No-op edits do not create history records.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Schema verification:**
   - Convex dashboard shows `editHistory` table
   - Table has columns: applicationId, field, oldValue, newValue, editedAt
   - Indexes `by_application` and `by_application_field` exist

2. **Mutation verification:**
   - Call `updateField` with a real application ID and field
   - Verify application field is updated in `applications` table
   - Verify history record created in `editHistory` table
   - Verify calling with same value returns `{ changed: false }` and creates no history

3. **Query verification:**
   - Call `getEditHistory` with the same application ID
   - Returns array with the edit record(s)
   - Records are ordered most recent first (desc by editedAt)
</verification>

<success_criteria>
Phase 8 success criteria (from roadmap) all satisfied:
1. [x] `editHistory` table exists in Convex schema with applicationId, field, oldValue, newValue, editedAt
2. [x] `updateField` mutation atomically updates application AND creates history record
3. [x] `getEditHistory` query returns history records for an application ordered by timestamp
4. [x] Editing a field via direct Convex call correctly records the change in history
</success_criteria>

<output>
After completion, create `.planning/phases/08-edit-infrastructure/08-01-SUMMARY.md`
</output>
