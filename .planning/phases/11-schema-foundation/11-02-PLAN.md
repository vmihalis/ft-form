---
phase: 11-schema-foundation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - convex/forms.ts
  - convex/submissions.ts
autonomous: true

must_haves:
  truths:
    - "Form can be created with name and slug, slug is unique"
    - "Publishing a form creates an immutable version snapshot"
    - "Submission references formVersionId, not formId"
    - "Submissions store data as JSON string with version reference"
    - "Form can be retrieved by slug for public rendering"
  artifacts:
    - path: "convex/forms.ts"
      provides: "Mutations and queries for form CRUD and publishing"
      exports: ["create", "update", "publish", "archive", "getBySlug", "getById", "list"]
    - path: "convex/submissions.ts"
      provides: "Mutations and queries for submission CRUD"
      exports: ["submit", "getWithSchema", "list", "updateStatus"]
  key_links:
    - from: "convex/forms.ts"
      to: "convex/schema.ts"
      via: "ctx.db operations on forms and formVersions tables"
      pattern: "ctx\\.db\\.(insert|patch|get|query).*forms"
    - from: "convex/submissions.ts"
      to: "convex/schema.ts"
      via: "ctx.db operations on submissions table with formVersionId reference"
      pattern: "formVersionId.*v\\.id\\(\"formVersions\"\\)"
---

<objective>
Create Convex mutations and queries for form CRUD, publishing, and submission handling.

Purpose: Enable form creation with slug uniqueness, immutable version snapshots on publish, and submissions that reference specific form versions. This completes the database API layer that the Form Builder UI (Phase 14) and Dynamic Form Renderer (Phase 13) will use.

Output:
- `convex/forms.ts` - Form CRUD mutations + publish + queries
- `convex/submissions.ts` - Submission mutations + queries with schema lookup
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-schema-foundation/11-RESEARCH.md
@.planning/phases/11-schema-foundation/11-01-SUMMARY.md
@convex/schema.ts
@src/types/form-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forms.ts with CRUD and publishing mutations</name>
  <files>convex/forms.ts</files>
  <action>
Create `convex/forms.ts` with the following mutations and queries:

```typescript
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// Reserved slugs that conflict with app routes
const RESERVED_SLUGS = ["admin", "api", "apply", "login", "logout", "auth", "_next"];

/**
 * Normalize slug to URL-safe format
 * - lowercase
 * - alphanumeric + hyphens only
 * - no leading/trailing hyphens
 * - no consecutive hyphens
 */
function normalizeSlug(slug: string): string {
  return slug
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
}

/**
 * Create a new form with empty schema
 */
export const create = mutation({
  args: {
    name: v.string(),
    slug: v.string(),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const slug = normalizeSlug(args.slug);

    if (!slug) {
      throw new Error("Slug cannot be empty");
    }

    if (RESERVED_SLUGS.includes(slug)) {
      throw new Error(`"${slug}" is a reserved path`);
    }

    // Check for existing slug (manual unique constraint)
    const existing = await ctx.db
      .query("forms")
      .withIndex("by_slug", (q) => q.eq("slug", slug))
      .first();

    if (existing) {
      throw new Error(`A form with slug "${slug}" already exists`);
    }

    // Empty schema for new forms
    const emptySchema = JSON.stringify({
      steps: [],
      settings: {
        submitButtonText: "Submit",
        successMessage: "Thank you for your submission!",
      },
    });

    const now = Date.now();
    return await ctx.db.insert("forms", {
      name: args.name,
      slug,
      description: args.description,
      status: "draft",
      draftSchema: emptySchema,
      createdAt: now,
      updatedAt: now,
    });
  },
});

/**
 * Update form metadata and draft schema
 */
export const update = mutation({
  args: {
    formId: v.id("forms"),
    name: v.optional(v.string()),
    slug: v.optional(v.string()),
    description: v.optional(v.string()),
    draftSchema: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const form = await ctx.db.get(args.formId);
    if (!form) throw new Error("Form not found");

    const updates: Record<string, unknown> = {
      updatedAt: Date.now(),
    };

    if (args.name !== undefined) {
      updates.name = args.name;
    }

    if (args.description !== undefined) {
      updates.description = args.description;
    }

    if (args.draftSchema !== undefined) {
      // Validate JSON
      try {
        JSON.parse(args.draftSchema);
      } catch {
        throw new Error("Invalid JSON in draftSchema");
      }
      updates.draftSchema = args.draftSchema;
    }

    if (args.slug !== undefined) {
      const slug = normalizeSlug(args.slug);

      if (!slug) {
        throw new Error("Slug cannot be empty");
      }

      if (RESERVED_SLUGS.includes(slug)) {
        throw new Error(`"${slug}" is a reserved path`);
      }

      // Check uniqueness (excluding current form)
      const existing = await ctx.db
        .query("forms")
        .withIndex("by_slug", (q) => q.eq("slug", slug))
        .first();

      if (existing && existing._id !== args.formId) {
        throw new Error(`A form with slug "${slug}" already exists`);
      }

      updates.slug = slug;
    }

    await ctx.db.patch(args.formId, updates);
    return args.formId;
  },
});

/**
 * Publish form - creates immutable version snapshot
 */
export const publish = mutation({
  args: { formId: v.id("forms") },
  handler: async (ctx, args) => {
    const form = await ctx.db.get(args.formId);
    if (!form) throw new Error("Form not found");

    // Validate schema before publishing
    let schema;
    try {
      schema = JSON.parse(form.draftSchema);
    } catch {
      throw new Error("Invalid form schema: malformed JSON");
    }

    if (!schema.steps || !Array.isArray(schema.steps)) {
      throw new Error("Invalid schema: missing steps array");
    }

    // Get next version number
    const latestVersion = await ctx.db
      .query("formVersions")
      .withIndex("by_form", (q) => q.eq("formId", args.formId))
      .order("desc")
      .first();

    const nextVersion = (latestVersion?.version ?? 0) + 1;

    // Create immutable snapshot
    const versionId = await ctx.db.insert("formVersions", {
      formId: args.formId,
      version: nextVersion,
      schema: form.draftSchema,
      publishedAt: Date.now(),
    });

    // Update form status and current version reference
    await ctx.db.patch(args.formId, {
      status: "published",
      currentVersionId: versionId,
      updatedAt: Date.now(),
    });

    return { versionId, version: nextVersion };
  },
});

/**
 * Archive form - makes it unavailable for new submissions
 */
export const archive = mutation({
  args: { formId: v.id("forms") },
  handler: async (ctx, args) => {
    const form = await ctx.db.get(args.formId);
    if (!form) throw new Error("Form not found");

    await ctx.db.patch(args.formId, {
      status: "archived",
      updatedAt: Date.now(),
    });

    return args.formId;
  },
});

/**
 * Get form by slug (for public form rendering)
 * Returns null if form doesn't exist or isn't published
 */
export const getBySlug = query({
  args: { slug: v.string() },
  handler: async (ctx, args) => {
    const form = await ctx.db
      .query("forms")
      .withIndex("by_slug", (q) => q.eq("slug", args.slug))
      .first();

    if (!form || form.status !== "published") {
      return null;
    }

    if (!form.currentVersionId) {
      return null;
    }

    const version = await ctx.db.get(form.currentVersionId);
    if (!version) return null;

    return {
      formId: form._id,
      formName: form.name,
      versionId: version._id,
      version: version.version,
      schema: JSON.parse(version.schema),
    };
  },
});

/**
 * Get form by ID (for admin editing)
 */
export const getById = query({
  args: { formId: v.id("forms") },
  handler: async (ctx, args) => {
    const form = await ctx.db.get(args.formId);
    if (!form) return null;

    return {
      ...form,
      draftSchema: JSON.parse(form.draftSchema),
    };
  },
});

/**
 * List all forms (for admin dashboard)
 */
export const list = query({
  handler: async (ctx) => {
    const forms = await ctx.db
      .query("forms")
      .order("desc")
      .collect();

    return forms.map((form) => ({
      _id: form._id,
      name: form.name,
      slug: form.slug,
      description: form.description,
      status: form.status,
      currentVersionId: form.currentVersionId,
      createdAt: form.createdAt,
      updatedAt: form.updatedAt,
      // Don't include draftSchema in list view for performance
    }));
  },
});

/**
 * Get all versions of a form (for version history)
 */
export const listVersions = query({
  args: { formId: v.id("forms") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("formVersions")
      .withIndex("by_form", (q) => q.eq("formId", args.formId))
      .order("desc")
      .collect();
  },
});
```

Key behaviors:
- `create`: Validates slug uniqueness and reserved paths, creates with empty schema
- `update`: Validates slug if changed, validates JSON if draftSchema provided
- `publish`: Creates immutable version snapshot, increments version number
- `archive`: Sets status to archived
- `getBySlug`: Returns published form with parsed schema (for public rendering)
- `getById`: Returns form with parsed draftSchema (for admin editing)
- `list`: Returns all forms without schema (for admin list view performance)
  </action>
  <verify>
Run Convex dev to validate mutations compile:
```bash
npx convex dev --once
```

Test via Convex dashboard or quick script:
1. Create a form via dashboard mutation tester
2. Verify slug uniqueness error on duplicate
3. Publish and verify version created
  </verify>
  <done>
- `convex/forms.ts` exists with create, update, publish, archive, getBySlug, getById, list, listVersions exports
- Slug uniqueness enforced (throws on duplicate)
- Reserved slugs rejected (admin, api, apply, etc.)
- Publishing creates formVersion with incremented version number
- Form status transitions work (draft -> published -> archived)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create submissions.ts with submission handling</name>
  <files>convex/submissions.ts</files>
  <action>
Create `convex/submissions.ts` with submission mutations and queries:

```typescript
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

/**
 * Submit a form response
 * Links to formVersionId (immutable), not formId
 */
export const submit = mutation({
  args: {
    formVersionId: v.id("formVersions"),
    data: v.string(), // JSON.stringify({ [fieldId]: value })
  },
  handler: async (ctx, args) => {
    // Verify version exists
    const version = await ctx.db.get(args.formVersionId);
    if (!version) throw new Error("Form version not found");

    // Verify form is still accepting submissions (not archived)
    const form = await ctx.db.get(version.formId);
    if (!form) throw new Error("Form not found");
    if (form.status === "archived") {
      throw new Error("This form is no longer accepting submissions");
    }

    // Validate data is valid JSON
    try {
      JSON.parse(args.data);
    } catch {
      throw new Error("Invalid submission data format");
    }

    return await ctx.db.insert("submissions", {
      formVersionId: args.formVersionId,
      data: args.data,
      status: "new",
      submittedAt: Date.now(),
    });
  },
});

/**
 * Get submission with its schema (for display)
 */
export const getWithSchema = query({
  args: { submissionId: v.id("submissions") },
  handler: async (ctx, args) => {
    const submission = await ctx.db.get(args.submissionId);
    if (!submission) return null;

    const version = await ctx.db.get(submission.formVersionId);
    if (!version) return null;

    const form = await ctx.db.get(version.formId);

    return {
      submission: {
        ...submission,
        data: JSON.parse(submission.data),
      },
      schema: JSON.parse(version.schema),
      formName: form?.name ?? "Unknown Form",
      formSlug: form?.slug,
      version: version.version,
    };
  },
});

/**
 * List submissions (for admin dashboard)
 * Optionally filter by formId
 */
export const list = query({
  args: {
    formId: v.optional(v.id("forms")),
    status: v.optional(
      v.union(
        v.literal("new"),
        v.literal("under_review"),
        v.literal("accepted"),
        v.literal("rejected")
      )
    ),
  },
  handler: async (ctx, args) => {
    let submissions;

    if (args.status) {
      submissions = await ctx.db
        .query("submissions")
        .withIndex("by_status", (q) => q.eq("status", args.status!))
        .order("desc")
        .collect();
    } else {
      submissions = await ctx.db
        .query("submissions")
        .order("desc")
        .collect();
    }

    // If filtering by formId, we need to check each submission's version
    if (args.formId) {
      const versionIds = new Set<string>();
      const versions = await ctx.db
        .query("formVersions")
        .withIndex("by_form", (q) => q.eq("formId", args.formId!))
        .collect();

      versions.forEach((v) => versionIds.add(v._id));
      submissions = submissions.filter((s) => versionIds.has(s.formVersionId));
    }

    // Enrich with form name for list display
    const enriched = await Promise.all(
      submissions.map(async (submission) => {
        const version = await ctx.db.get(submission.formVersionId);
        const form = version ? await ctx.db.get(version.formId) : null;

        return {
          _id: submission._id,
          formVersionId: submission.formVersionId,
          status: submission.status,
          submittedAt: submission.submittedAt,
          formName: form?.name ?? "Unknown Form",
          formSlug: form?.slug,
          version: version?.version,
          // Don't include full data in list for performance
        };
      })
    );

    return enriched;
  },
});

/**
 * Update submission status
 */
export const updateStatus = mutation({
  args: {
    submissionId: v.id("submissions"),
    status: v.union(
      v.literal("new"),
      v.literal("under_review"),
      v.literal("accepted"),
      v.literal("rejected")
    ),
  },
  handler: async (ctx, args) => {
    const submission = await ctx.db.get(args.submissionId);
    if (!submission) throw new Error("Submission not found");

    await ctx.db.patch(args.submissionId, {
      status: args.status,
    });

    return args.submissionId;
  },
});

/**
 * Update a field in submission data (for admin editing)
 * Creates edit history entry
 */
export const updateField = mutation({
  args: {
    submissionId: v.id("submissions"),
    fieldId: v.string(),
    fieldLabel: v.string(),
    newValue: v.string(),
  },
  handler: async (ctx, args) => {
    const submission = await ctx.db.get(args.submissionId);
    if (!submission) throw new Error("Submission not found");

    const data = JSON.parse(submission.data) as Record<string, unknown>;
    const oldValue = String(data[args.fieldId] ?? "");

    // Skip if value unchanged
    if (oldValue === args.newValue) {
      return args.submissionId;
    }

    // Update the data
    data[args.fieldId] = args.newValue;
    await ctx.db.patch(args.submissionId, {
      data: JSON.stringify(data),
    });

    // Create edit history entry
    await ctx.db.insert("submissionEditHistory", {
      submissionId: args.submissionId,
      fieldId: args.fieldId,
      fieldLabel: args.fieldLabel,
      oldValue,
      newValue: args.newValue,
      editedAt: Date.now(),
    });

    return args.submissionId;
  },
});

/**
 * Get edit history for a submission
 */
export const getEditHistory = query({
  args: { submissionId: v.id("submissions") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("submissionEditHistory")
      .withIndex("by_submission", (q) => q.eq("submissionId", args.submissionId))
      .order("desc")
      .collect();
  },
});
```

Key behaviors:
- `submit`: Validates version exists, form not archived, data is valid JSON
- `getWithSchema`: Returns submission with parsed data AND schema for display
- `list`: Returns submissions with form metadata, optional formId/status filter
- `updateStatus`: Changes submission status
- `updateField`: Updates single field value, creates edit history entry
- `getEditHistory`: Returns edit history for a submission
  </action>
  <verify>
Run Convex dev to validate mutations compile:
```bash
npx convex dev --once
```

Verify via Convex dashboard:
1. Create a form (via forms.create)
2. Publish the form (via forms.publish)
3. Submit to the form version (via submissions.submit)
4. Query submission with schema (via submissions.getWithSchema)
  </verify>
  <done>
- `convex/submissions.ts` exists with submit, getWithSchema, list, updateStatus, updateField, getEditHistory exports
- Submit requires valid formVersionId (not formId)
- Submit rejects if form is archived
- getWithSchema returns parsed data AND schema
- updateField creates edit history entry
- list supports filtering by formId and status
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Convex compiles: `npx convex dev --once`
2. Lint passes: `npm run lint`

End-to-end verification via Convex dashboard:
1. forms.create with name="Test Form", slug="test-form" -> returns formId
2. forms.create with slug="test-form" -> throws "already exists" error
3. forms.create with slug="admin" -> throws "reserved path" error
4. forms.publish with formId -> returns { versionId, version: 1 }
5. forms.getBySlug with slug="test-form" -> returns form with parsed schema
6. submissions.submit with formVersionId, data='{"field_1":"value"}' -> returns submissionId
7. submissions.getWithSchema with submissionId -> returns submission + schema + formName
</verification>

<success_criteria>
- [ ] `convex/forms.ts` exists with all required exports
- [ ] `convex/submissions.ts` exists with all required exports
- [ ] Slug uniqueness enforced
- [ ] Publishing creates immutable version
- [ ] Submissions link to formVersionId
- [ ] getWithSchema returns both data and schema
- [ ] Convex compilation succeeds
- [ ] No regressions to existing applications.ts functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-schema-foundation/11-02-SUMMARY.md`
</output>
