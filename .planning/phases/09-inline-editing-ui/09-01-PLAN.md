---
phase: 09-inline-editing-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/admin/EditableField.tsx
  - src/lib/constants/estimatedSizes.ts
autonomous: true

must_haves:
  truths:
    - "EditableField renders value normally when not editing"
    - "Clicking the field or pencil icon enters edit mode"
    - "Pressing Enter or blurring saves the change"
    - "Pressing Escape cancels and reverts to original value"
    - "Invalid input shows error and prevents save"
    - "Pencil icon appears on hover"
    - "Edit mode shows visual distinction (border/background)"
  artifacts:
    - path: "src/components/admin/EditableField.tsx"
      provides: "Reusable inline editing component"
      exports: ["EditableField"]
    - path: "src/lib/constants/estimatedSizes.ts"
      provides: "Estimated size options for select variant"
      exports: ["ESTIMATED_SIZES"]
  key_links:
    - from: "src/components/admin/EditableField.tsx"
      to: "api.applications.updateField"
      via: "useMutation hook"
      pattern: "useMutation.*updateField"
    - from: "src/components/admin/EditableField.tsx"
      to: "src/lib/schemas/application.ts"
      via: "Zod validation import"
      pattern: "from.*schemas/application"
---

<objective>
Create the EditableField component that handles inline editing for all field types (text, textarea, select, date).

Purpose: Provide a reusable component with consistent UX patterns (click-to-edit, Enter/Escape, validation, visual states) that can be used for all 19 application fields.

Output: EditableField component with text, textarea, select, and date variants, integrated with updateField mutation and Zod validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-inline-editing-ui/09-RESEARCH.md

# Existing code to reference
@src/components/admin/ApplicationSheet.tsx (current Field component pattern)
@src/components/admin/StatusDropdown.tsx (mutation pattern example)
@src/lib/schemas/application.ts (validation schemas)
@src/lib/constants/floors.ts (FRONTIER_TOWER_FLOORS for select options)
@src/components/ui/input.tsx
@src/components/ui/textarea.tsx
@src/components/ui/select.tsx
@convex/applications.ts (updateField mutation signature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create estimated sizes constant</name>
  <files>src/lib/constants/estimatedSizes.ts</files>
  <action>
Create a constants file for estimated community size options, following the same pattern as floors.ts.

Content:
```typescript
export const ESTIMATED_SIZES = [
  { value: "1-10", label: "1-10 members" },
  { value: "11-25", label: "11-25 members" },
  { value: "26-50", label: "26-50 members" },
  { value: "51-100", label: "51-100 members" },
  { value: "100+", label: "100+ members" },
] as const;

export type EstimatedSizeValue = (typeof ESTIMATED_SIZES)[number]["value"];

export function getEstimatedSizeLabel(value: string): string {
  const size = ESTIMATED_SIZES.find((s) => s.value === value);
  return size?.label ?? value;
}
```

This extracts the hardcoded values from ProposalStep.tsx into a reusable constant for the EditableField select variant.
  </action>
  <verify>File exists and exports are correct: `grep -l "ESTIMATED_SIZES" src/lib/constants/estimatedSizes.ts`</verify>
  <done>estimatedSizes.ts exists with ESTIMATED_SIZES array, type, and helper function</done>
</task>

<task type="auto">
  <name>Task 2: Create EditableField component</name>
  <files>src/components/admin/EditableField.tsx</files>
  <action>
Create the EditableField component with the following structure:

**Props interface:**
```typescript
interface EditableFieldProps {
  applicationId: Id<"applications">;
  field: string;           // Field key in application (e.g., "fullName")
  label: string;           // Display label (e.g., "Name")
  value: string | undefined;
  type: "text" | "textarea" | "select" | "date" | "email" | "url";
  options?: { value: string; label: string }[];  // For select type
  required?: boolean;      // Default true
  maxLength?: number;      // For tagline (100)
}
```

**State management:**
- `isEditing: boolean` - Whether field is in edit mode
- `editValue: string` - Current value being edited
- `error: string | null` - Validation error message

**Key behaviors:**

1. **Display mode (isEditing=false):**
   - Show label in muted text above
   - Show value (or "Not set" if undefined for optional fields)
   - On hover: show pencil icon (Pencil from lucide-react) on the right
   - On click anywhere in field area: enter edit mode
   - Add `group` class and `hover:bg-muted/50` for hover state
   - Add `cursor-pointer` to indicate clickability

2. **Edit mode (isEditing=true):**
   - Show appropriate input based on type:
     - `text`, `email`, `url`: Input component
     - `textarea`: Textarea component (rows=3, resize-none)
     - `select`: Select component with provided options
     - `date`: Input with type="date"
   - Add `ring-2 ring-ring` border to indicate edit state
   - Auto-focus the input on mount
   - For text/textarea: select all text on focus

3. **Save logic (handleSave):**
   - Validate using field-specific Zod schema:
     - `email`: z.string().email()
     - `url`: z.string().url().optional().or(z.literal(""))
     - Required fields: z.string().min(1)
     - tagline: z.string().max(100)
   - If validation fails: set error state, do NOT exit edit mode
   - If validation passes: call updateField mutation
   - On mutation success: exit edit mode
   - On mutation error: show error toast (use sonner if available, else console.error)

4. **Cancel logic (handleCancel):**
   - Reset editValue to original value
   - Clear error
   - Exit edit mode

5. **Keyboard handling:**
   - Enter: save (for text/email/url/date/select only - NOT textarea)
   - Escape: cancel
   - For textarea: Ctrl+Enter or Cmd+Enter to save

6. **Blur handling:**
   - On blur: check `relatedTarget` - if clicking within same component, ignore
   - Otherwise: save

**Validation map (create inside component or as helper):**
```typescript
const getFieldValidator = (field: string, type: string, required: boolean, maxLength?: number) => {
  let schema = z.string();

  if (type === "email") {
    schema = z.string().email("Please enter a valid email");
  } else if (type === "url") {
    return z.string().url("Please enter a valid URL").optional().or(z.literal(""));
  }

  if (required) {
    schema = schema.min(1, "This field is required");
  }

  if (maxLength) {
    schema = schema.max(maxLength, `Maximum ${maxLength} characters`);
  }

  return schema;
};
```

**Import requirements:**
- `useMutation` from "convex/react"
- `api` from "../../../convex/_generated/api"
- `Id` from "../../../convex/_generated/dataModel"
- `Input`, `Textarea`, `Select` components from ui
- `Pencil` from "lucide-react"
- `z` from "zod"
- `cn` from "@/lib/utils"

**Handle Convex re-renders (CRITICAL - see research pitfall #1):**
Only sync external `value` prop to `editValue` when NOT in editing mode. Use useEffect:
```typescript
useEffect(() => {
  if (!isEditing) {
    setEditValue(value ?? "");
  }
}, [value, isEditing]);
```

**Handle blur race condition (CRITICAL - see research pitfall #2):**
Use ref to track if clicking within component, or use small setTimeout in blur handler.
  </action>
  <verify>
1. Component file exists: `ls src/components/admin/EditableField.tsx`
2. Exports EditableField: `grep "export.*EditableField" src/components/admin/EditableField.tsx`
3. Uses updateField mutation: `grep "updateField" src/components/admin/EditableField.tsx`
4. Has validation: `grep "zod\|\.email\|\.min" src/components/admin/EditableField.tsx`
  </verify>
  <done>
- EditableField component exists with text, textarea, select, date, email, url variants
- Component shows pencil icon on hover
- Click enters edit mode with visual distinction
- Enter saves (Ctrl+Enter for textarea), Escape cancels
- Blur saves unless clicking cancel
- Validation prevents save on invalid input with error message
- Calls updateField mutation to persist changes
  </done>
</task>

</tasks>

<verification>
1. **File structure:**
   - `src/components/admin/EditableField.tsx` exists
   - `src/lib/constants/estimatedSizes.ts` exists

2. **Component exports:**
   - EditableField is exported
   - ESTIMATED_SIZES is exported

3. **TypeScript compilation:**
   - `npx tsc --noEmit` passes without errors in these files
</verification>

<success_criteria>
- EditableField component created with all field type variants
- Estimated sizes constant extracted for reuse
- Component implements full edit lifecycle (click -> edit -> save/cancel)
- Validation integrated using Zod schemas
- Visual states implemented (hover, editing, error)
- Ready for integration into ApplicationSheet in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/09-inline-editing-ui/09-01-SUMMARY.md`
</output>
