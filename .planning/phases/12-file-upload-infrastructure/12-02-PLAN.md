---
phase: 12-file-upload-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - package.json
  - src/hooks/useFileUpload.ts
  - src/components/form/fields/FileField.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can drag-and-drop or click to select a file"
    - "Selected file uploads immediately with progress indicator"
    - "Uploaded file shows preview with remove button"
    - "Upload errors display user-friendly message"
    - "File field accepts configurable file types and size limit"
  artifacts:
    - path: "src/hooks/useFileUpload.ts"
      provides: "Upload logic with progress tracking"
      exports: ["useFileUpload"]
      min_lines: 40
    - path: "src/components/form/fields/FileField.tsx"
      provides: "Drag-and-drop file upload component"
      exports: ["FileField"]
      min_lines: 80
  key_links:
    - from: "src/hooks/useFileUpload.ts"
      to: "convex/storage.ts"
      via: "useMutation generateUploadUrl"
      pattern: "api\\.storage\\.generateUploadUrl"
    - from: "src/components/form/fields/FileField.tsx"
      to: "src/hooks/useFileUpload.ts"
      via: "useFileUpload hook"
      pattern: "useFileUpload\\(\\)"
    - from: "src/components/form/fields/FileField.tsx"
      to: "convex/storage.ts"
      via: "useQuery getFileUrl"
      pattern: "api\\.storage\\.getFileUrl"
---

<objective>
Create React hook and component for file uploads with drag-and-drop UX, immediate persistence, and progress tracking.

Purpose: Provides the frontend infrastructure for file upload fields in dynamic forms. Files upload immediately when selected (not on form submit), storing `Id<"_storage">` in form data.

Output: useFileUpload hook and FileField component ready for use in dynamic form renderer (Phase 13).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-file-upload-infrastructure/12-RESEARCH.md
@.planning/phases/12-file-upload-infrastructure/12-01-SUMMARY.md

# Reference existing component patterns
@src/components/ui/button.tsx
@src/components/form/FormSteps.tsx
@src/hooks/useMobileKeyboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-dropzone and create useFileUpload hook</name>
  <files>package.json, src/hooks/useFileUpload.ts</files>
  <action>
1. Install react-dropzone:
   ```bash
   npm install react-dropzone
   ```

2. Create src/hooks/useFileUpload.ts:

```typescript
import { useState, useCallback } from "react";
import { useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import type { Id } from "../../convex/_generated/dataModel";

interface UploadState {
  isUploading: boolean;
  progress: number;  // 0-100
  error: string | null;
}

export function useFileUpload() {
  const generateUploadUrl = useMutation(api.storage.generateUploadUrl);
  const [state, setState] = useState<UploadState>({
    isUploading: false,
    progress: 0,
    error: null,
  });

  const uploadFile = useCallback(async (file: File): Promise<Id<"_storage"> | null> => {
    setState({ isUploading: true, progress: 0, error: null });

    try {
      // Step 1: Get signed upload URL from Convex
      const postUrl = await generateUploadUrl();

      // Step 2: Upload with XMLHttpRequest for progress tracking
      // (fetch doesn't support upload progress)
      const storageId = await new Promise<Id<"_storage">>((resolve, reject) => {
        const xhr = new XMLHttpRequest();

        xhr.upload.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            const progress = Math.round((event.loaded / event.total) * 100);
            setState(s => ({ ...s, progress }));
          }
        });

        xhr.addEventListener("load", () => {
          if (xhr.status === 200) {
            const { storageId } = JSON.parse(xhr.responseText);
            resolve(storageId as Id<"_storage">);
          } else {
            reject(new Error(`Upload failed with status ${xhr.status}`));
          }
        });

        xhr.addEventListener("error", () => reject(new Error("Network error during upload")));
        xhr.addEventListener("abort", () => reject(new Error("Upload cancelled")));

        xhr.open("POST", postUrl);
        xhr.setRequestHeader("Content-Type", file.type);
        xhr.send(file);
      });

      setState({ isUploading: false, progress: 100, error: null });
      return storageId;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Upload failed";
      setState({ isUploading: false, progress: 0, error: message });
      return null;
    }
  }, [generateUploadUrl]);

  const reset = useCallback(() => {
    setState({ isUploading: false, progress: 0, error: null });
  }, []);

  return { ...state, uploadFile, reset };
}
```

Key implementation notes:
- Uses XMLHttpRequest (not fetch) for upload.onprogress support
- Returns Id<"_storage"> on success, null on failure
- State includes isUploading, progress (0-100), error
- reset() function to clear error state
  </action>
  <verify>
`npm run build` compiles without errors.
Check that convex/_generated/api.ts includes storage exports.
  </verify>
  <done>
react-dropzone installed. useFileUpload hook created with progress tracking via XMLHttpRequest.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileField component with drag-and-drop</name>
  <files>src/components/form/fields/FileField.tsx</files>
  <action>
Create src/components/form/fields/FileField.tsx:

```typescript
"use client";

import { useCallback, useState } from "react";
import { useDropzone, FileRejection } from "react-dropzone";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import type { Id } from "../../../../convex/_generated/dataModel";
import { useFileUpload } from "@/hooks/useFileUpload";
import { cn } from "@/lib/utils";
import { Upload, X, FileIcon, Loader2, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface FileFieldProps {
  value: Id<"_storage"> | null;
  onChange: (storageId: Id<"_storage"> | null) => void;
  accept?: Record<string, string[]>;  // e.g., { "image/*": [], "application/pdf": [] }
  maxSize?: number;  // bytes, default 50MB
  label?: string;
  description?: string;
  disabled?: boolean;
}

const DEFAULT_MAX_SIZE = 50 * 1024 * 1024; // 50MB
const DEFAULT_ACCEPT = {
  "image/*": [".png", ".jpg", ".jpeg", ".gif", ".webp"],
  "application/pdf": [".pdf"],
};

export function FileField({
  value,
  onChange,
  accept = DEFAULT_ACCEPT,
  maxSize = DEFAULT_MAX_SIZE,
  label,
  description,
  disabled = false,
}: FileFieldProps) {
  const { isUploading, progress, error: uploadError, uploadFile, reset } = useFileUpload();
  const [rejectionError, setRejectionError] = useState<string | null>(null);

  // Get file URL for preview if we have a value
  const fileUrl = useQuery(
    api.storage.getFileUrl,
    value ? { storageId: value } : "skip"
  );

  const onDrop = useCallback(async (
    acceptedFiles: File[],
    rejectedFiles: FileRejection[]
  ) => {
    setRejectionError(null);
    reset();

    if (rejectedFiles.length > 0) {
      const rejection = rejectedFiles[0];
      const error = rejection.errors[0];

      if (error.code === "file-too-large") {
        const maxMB = Math.round(maxSize / 1024 / 1024);
        setRejectionError(`File too large. Maximum size is ${maxMB}MB`);
      } else if (error.code === "file-invalid-type") {
        setRejectionError("Invalid file type. Please upload an image or PDF.");
      } else {
        setRejectionError(error.message);
      }
      return;
    }

    if (acceptedFiles.length > 0) {
      const storageId = await uploadFile(acceptedFiles[0]);
      if (storageId) {
        onChange(storageId);
      }
    }
  }, [uploadFile, onChange, maxSize, reset]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept,
    maxSize,
    maxFiles: 1,
    disabled: disabled || isUploading,
  });

  const handleRemove = useCallback(() => {
    onChange(null);
    setRejectionError(null);
    reset();
  }, [onChange, reset]);

  const displayError = uploadError || rejectionError;

  // Show uploaded file with preview/link
  if (value && fileUrl) {
    return (
      <div className="space-y-2">
        {label && <p className="text-sm font-medium text-foreground">{label}</p>}
        <div className="flex items-center gap-3 p-4 border rounded-lg bg-muted/30">
          <FileIcon className="h-8 w-8 text-muted-foreground shrink-0" />
          <div className="flex-1 min-w-0">
            <a
              href={fileUrl}
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm font-medium text-primary hover:underline truncate block"
            >
              View uploaded file
            </a>
            <p className="text-xs text-muted-foreground">Click to open in new tab</p>
          </div>
          <Button
            type="button"
            variant="ghost"
            size="icon"
            onClick={handleRemove}
            disabled={disabled}
            aria-label="Remove file"
            className="shrink-0"
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>
    );
  }

  // Show uploading state
  if (isUploading) {
    return (
      <div className="space-y-2">
        {label && <p className="text-sm font-medium text-foreground">{label}</p>}
        <div className="border-2 border-dashed rounded-lg p-6 text-center bg-muted/20">
          <Loader2 className="h-8 w-8 mx-auto animate-spin text-primary" />
          <p className="text-sm text-muted-foreground mt-2">Uploading... {progress}%</p>
          <div className="w-full bg-muted rounded-full h-2 mt-3 max-w-xs mx-auto">
            <div
              className="bg-primary h-2 rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>
      </div>
    );
  }

  // Show dropzone
  return (
    <div className="space-y-2">
      {label && <p className="text-sm font-medium text-foreground">{label}</p>}
      {description && <p className="text-sm text-muted-foreground">{description}</p>}

      <div
        {...getRootProps()}
        className={cn(
          "border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors",
          isDragActive && "border-primary bg-primary/5",
          displayError && "border-destructive bg-destructive/5",
          disabled && "cursor-not-allowed opacity-50",
          !isDragActive && !displayError && !disabled && "hover:border-primary/50 hover:bg-muted/30"
        )}
      >
        <input {...getInputProps()} />

        <Upload className={cn(
          "h-8 w-8 mx-auto",
          displayError ? "text-destructive" : "text-muted-foreground"
        )} />

        <p className="text-sm mt-2">
          {isDragActive
            ? "Drop file here..."
            : "Drag and drop or click to select"}
        </p>
        <p className="text-xs text-muted-foreground mt-1">
          Images or PDF, max {Math.round(maxSize / 1024 / 1024)}MB
        </p>
      </div>

      {displayError && (
        <div className="flex items-center gap-2 text-sm text-destructive">
          <AlertCircle className="h-4 w-4 shrink-0" />
          <span>{displayError}</span>
        </div>
      )}
    </div>
  );
}
```

Key implementation notes:
- Uses react-dropzone for drag-and-drop with accessibility
- Shows upload progress with animated progress bar
- Displays uploaded file with "View uploaded file" link
- Remove button clears the value
- Error handling for file rejection (size, type) and upload failures
- Follows existing component patterns (cn utility, shadcn Button)
- Default accepts images and PDFs up to 50MB
  </action>
  <verify>
`npm run build` compiles without TypeScript errors.
Create a simple test page or check the component can be imported without errors.
  </verify>
  <done>
FileField component created with drag-and-drop UI, progress indicator, file preview, remove functionality, and error handling.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without errors
2. react-dropzone is in package.json dependencies
3. useFileUpload hook exports correctly from src/hooks/useFileUpload.ts
4. FileField component can be imported and used (test with a simple page if needed)
5. TypeScript types are correct (Id<"_storage"> for storage IDs)
</verification>

<success_criteria>
- FileField component renders dropzone UI when no value
- Drag-and-drop and click-to-select both work
- Upload progress shows percentage and animated bar
- Uploaded file shows link to view and remove button
- Errors display for invalid file type, file too large, and network issues
- Component is ready for integration in Phase 13 dynamic form renderer
</success_criteria>

<output>
After completion, create `.planning/phases/12-file-upload-infrastructure/12-02-SUMMARY.md`
</output>
