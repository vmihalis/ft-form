---
phase: 06-admin-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/components/admin/columns.tsx
  - src/components/admin/StatusBadge.tsx
  - src/components/admin/FloorFilter.tsx
  - src/components/admin/SearchInput.tsx
  - src/components/admin/ApplicationsTable.tsx
autonomous: true

must_haves:
  truths:
    - "Table displays applications with name, email, floor, initiative, status, date columns"
    - "Real-time subscription updates table when new applications arrive"
    - "Floor filter limits visible rows to selected floor"
    - "Search filters rows by applicant name or initiative name"
    - "Loading state shows skeleton while data loads"
  artifacts:
    - path: "src/components/admin/columns.tsx"
      provides: "TanStack Table column definitions"
      exports: ["columns"]
      min_lines: 40
    - path: "src/components/admin/StatusBadge.tsx"
      provides: "Color-coded status badge"
      exports: ["StatusBadge"]
      min_lines: 20
    - path: "src/components/admin/FloorFilter.tsx"
      provides: "Floor dropdown filter"
      exports: ["FloorFilter"]
      min_lines: 30
    - path: "src/components/admin/SearchInput.tsx"
      provides: "Name/initiative search input"
      exports: ["SearchInput"]
      min_lines: 15
    - path: "src/components/admin/ApplicationsTable.tsx"
      provides: "Main table component with real-time data"
      exports: ["ApplicationsTable"]
      min_lines: 80
  key_links:
    - from: "src/components/admin/ApplicationsTable.tsx"
      to: "convex/applications.ts"
      via: "useQuery subscription"
      pattern: "useQuery.*api\\.applications\\.list"
    - from: "src/components/admin/columns.tsx"
      to: "src/components/admin/StatusBadge.tsx"
      via: "status cell render"
      pattern: "StatusBadge"
    - from: "src/components/admin/FloorFilter.tsx"
      to: "src/lib/constants/floors.ts"
      via: "floor options import"
      pattern: "FRONTIER_TOWER_FLOORS"
---

<objective>
Create the applications data table with TanStack Table, real-time Convex subscription, and filtering capabilities.

Purpose: Build the core table view that displays all submissions with filtering and search.
Output: Functional ApplicationsTable component with real-time updates, floor filter, and name/initiative search.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-admin-dashboard/06-RESEARCH.md

@convex/applications.ts
@src/lib/constants/floors.ts
@src/components/ui/table.tsx
@src/components/ui/badge.tsx
@src/components/ui/select.tsx
@src/components/ui/input.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StatusBadge, FloorFilter, and SearchInput components</name>
  <files>
    src/components/admin/StatusBadge.tsx
    src/components/admin/FloorFilter.tsx
    src/components/admin/SearchInput.tsx
  </files>
  <action>
    Create src/components/admin/ directory and three helper components:

    1. StatusBadge.tsx:
       - Takes status prop: "new" | "under_review" | "accepted" | "rejected"
       - Maps status to Badge variant:
         - new: "default" (primary blue)
         - under_review: "secondary" (gray)
         - accepted: "outline" with green text (className="border-green-500 text-green-600")
         - rejected: "destructive" (red)
       - Maps status to label: "New", "Under Review", "Accepted", "Rejected"

    2. FloorFilter.tsx:
       - Takes value and onValueChange props
       - Uses Select component from shadcn
       - Options: "All Floors" (value="all") + all floors from FRONTIER_TOWER_FLOORS
       - Import FRONTIER_TOWER_FLOORS from "@/lib/constants/floors"

    3. SearchInput.tsx:
       - Takes value and onChange props
       - Uses Input component from shadcn
       - Placeholder: "Search by name or initiative..."
       - Icon: Search icon from lucide-react (optional but nice)

    All components should be "use client" and have proper TypeScript types.
  </action>
  <verify>
    - All three files exist in src/components/admin/
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    StatusBadge, FloorFilter, and SearchInput components created with proper types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create column definitions for TanStack Table</name>
  <files>src/components/admin/columns.tsx</files>
  <action>
    Create columns.tsx with TanStack Table column definitions:

    Import:
    - ColumnDef from "@tanstack/react-table"
    - Doc from "@/convex/_generated/dataModel"
    - StatusBadge from "./StatusBadge"
    - getFloorLabel from "@/lib/constants/floors"

    Define columns array with type ColumnDef<Doc<"applications">>[] containing:

    1. fullName: header "Name", accessor "fullName"
    2. email: header "Email", accessor "email"
    3. floor: header "Floor", accessor "floor", cell renders getFloorLabel(value), filterFn: "equals"
    4. initiativeName: header "Initiative", accessor "initiativeName"
    5. status: header "Status", accessor "status", cell renders StatusBadge component
    6. submittedAt: header "Date", accessor "submittedAt", cell formats as locale date string

    Export the columns array.
  </action>
  <verify>
    - columns.tsx exists and exports columns array
    - TypeScript compiles without errors
  </verify>
  <done>
    Column definitions created with StatusBadge in status cell and floor label formatting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ApplicationsTable with real-time data and filtering</name>
  <files>src/components/admin/ApplicationsTable.tsx</files>
  <action>
    Create the main table component:

    1. "use client" directive at top

    2. Imports:
       - useState from "react"
       - useQuery from "convex/react"
       - api from "@/convex/_generated/api"
       - useReactTable, getCoreRowModel, getFilteredRowModel, flexRender, ColumnFiltersState from "@tanstack/react-table"
       - Table, TableBody, TableCell, TableHead, TableHeader, TableRow from "@/components/ui/table"
       - columns from "./columns"
       - FloorFilter from "./FloorFilter"
       - SearchInput from "./SearchInput"
       - Skeleton from "@/components/ui/skeleton" (if exists, otherwise inline skeleton)

    3. Component structure:
       ```typescript
       export function ApplicationsTable({ onRowClick }: { onRowClick?: (app: Doc<"applications">) => void }) {
         const applications = useQuery(api.applications.list);
         const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
         const [globalFilter, setGlobalFilter] = useState("");

         const table = useReactTable({
           data: applications ?? [],
           columns,
           state: { columnFilters, globalFilter },
           onColumnFiltersChange: setColumnFilters,
           onGlobalFilterChange: setGlobalFilter,
           getCoreRowModel: getCoreRowModel(),
           getFilteredRowModel: getFilteredRowModel(),
           globalFilterFn: (row, columnId, filterValue) => {
             // Only search fullName and initiativeName columns
             const name = row.getValue("fullName") as string;
             const initiative = row.getValue("initiativeName") as string;
             const search = filterValue.toLowerCase();
             return name.toLowerCase().includes(search) || initiative.toLowerCase().includes(search);
           },
         });

         // Loading state
         if (applications === undefined) {
           return <TableSkeleton />;
         }

         // Floor filter handler
         const handleFloorFilter = (value: string) => {
           table.getColumn("floor")?.setFilterValue(value === "all" ? undefined : value);
         };

         return (
           <div className="space-y-4">
             {/* Filters row */}
             <div className="flex gap-4">
               <FloorFilter
                 value={table.getColumn("floor")?.getFilterValue() as string ?? "all"}
                 onValueChange={handleFloorFilter}
               />
               <SearchInput
                 value={globalFilter}
                 onChange={(e) => setGlobalFilter(e.target.value)}
               />
             </div>

             {/* Table */}
             <div className="rounded-md border">
               <Table>
                 <TableHeader>
                   {table.getHeaderGroups().map((headerGroup) => (
                     <TableRow key={headerGroup.id}>
                       {headerGroup.headers.map((header) => (
                         <TableHead key={header.id}>
                           {flexRender(header.column.columnDef.header, header.getContext())}
                         </TableHead>
                       ))}
                     </TableRow>
                   ))}
                 </TableHeader>
                 <TableBody>
                   {table.getRowModel().rows.length ? (
                     table.getRowModel().rows.map((row) => (
                       <TableRow
                         key={row.id}
                         onClick={() => onRowClick?.(row.original)}
                         className="cursor-pointer hover:bg-muted/50"
                       >
                         {row.getVisibleCells().map((cell) => (
                           <TableCell key={cell.id}>
                             {flexRender(cell.column.columnDef.cell, cell.getContext())}
                           </TableCell>
                         ))}
                       </TableRow>
                     ))
                   ) : (
                     <TableRow>
                       <TableCell colSpan={columns.length} className="h-24 text-center">
                         No applications found.
                       </TableCell>
                     </TableRow>
                   )}
                 </TableBody>
               </Table>
             </div>
           </div>
         );
       }
       ```

    4. Create a simple TableSkeleton component (can be inline or separate):
       - 5 rows of skeleton bars matching column structure

    IMPORTANT: Check for undefined (loading) vs empty array (no data) - different states!
  </action>
  <verify>
    - ApplicationsTable.tsx exists and exports ApplicationsTable
    - TypeScript compiles: npx tsc --noEmit
    - Component accepts onRowClick prop for row selection
  </verify>
  <done>
    ApplicationsTable component with real-time Convex subscription, floor filter, name/initiative search, loading skeleton, and row click handler.
  </done>
</task>

</tasks>

<verification>
1. All five files exist in src/components/admin/
2. `npx tsc --noEmit` passes without errors
3. `grep "useQuery.*api.applications.list" src/components/admin/ApplicationsTable.tsx` returns match
4. `grep "FRONTIER_TOWER_FLOORS" src/components/admin/FloorFilter.tsx` returns match
5. `grep "StatusBadge" src/components/admin/columns.tsx` returns match
</verification>

<success_criteria>
- ApplicationsTable renders with all 6 columns (name, email, floor, initiative, status, date)
- Convex useQuery provides real-time data subscription
- Floor filter changes visible rows
- Search filters by name and initiative only
- Loading shows skeleton, empty shows "No applications found"
- Rows are clickable with onRowClick callback
</success_criteria>

<output>
After completion, create `.planning/phases/06-admin-dashboard/06-02-SUMMARY.md`
</output>
