---
phase: 15-admin-integration
plan: 03
type: execute
wave: 2
depends_on: ["15-02"]
files_modified:
  - src/components/admin/DynamicEditableField.tsx
  - src/components/admin/SubmissionSheet.tsx
  - src/components/admin/SubmissionEditHistory.tsx
  - src/components/admin/AdminTabs.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking a submission opens detail sheet with all form fields"
    - "Field display iterates over schema (not hardcoded)"
    - "Admin can edit submission field values inline"
    - "Select/radio fields show option labels, not raw values"
    - "Edit history shows field labels from when edit was made"
  artifacts:
    - path: "src/components/admin/DynamicEditableField.tsx"
      provides: "Schema-driven editable field component"
      exports: ["DynamicEditableField"]
    - path: "src/components/admin/SubmissionSheet.tsx"
      provides: "Detail sheet for dynamic submissions"
      exports: ["SubmissionSheet"]
    - path: "src/components/admin/SubmissionEditHistory.tsx"
      provides: "Edit history for submissions"
      exports: ["SubmissionEditHistory"]
  key_links:
    - from: "src/components/admin/SubmissionSheet.tsx"
      to: "convex/submissions.ts"
      via: "useQuery(api.submissions.getWithSchema)"
      pattern: "api\\.submissions\\.getWithSchema"
    - from: "src/components/admin/DynamicEditableField.tsx"
      to: "convex/submissions.ts"
      via: "useMutation(api.submissions.updateField)"
      pattern: "api\\.submissions\\.updateField"
    - from: "src/components/admin/SubmissionEditHistory.tsx"
      to: "convex/submissions.ts"
      via: "useQuery(api.submissions.getEditHistory)"
      pattern: "api\\.submissions\\.getEditHistory"
---

<objective>
Create submission detail sheet with schema-driven field display and edit history.

Purpose: Enable admins to view and edit dynamic form submissions without hardcoding field layouts. Fields render based on the schema snapshot from when the form was submitted.

Output: SubmissionSheet with DynamicEditableField components and SubmissionEditHistory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-admin-integration/15-RESEARCH.md

# Prior plan context
@.planning/phases/15-admin-integration/15-02-SUMMARY.md

# Patterns to follow
@src/components/admin/ApplicationSheet.tsx
@src/components/admin/EditableField.tsx
@src/components/admin/EditHistory.tsx
@src/components/dynamic-form/DynamicReview.tsx
@convex/submissions.ts
@src/types/form-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicEditableField Component</name>
  <files>
    src/components/admin/DynamicEditableField.tsx
  </files>
  <action>
Create DynamicEditableField by adapting EditableField to work with dynamic schema fields.

Key differences from EditableField:
- Uses api.submissions.updateField instead of api.applications.updateField
- Requires submissionId and fieldLabel (for edit history)
- Handles select/radio option label lookup from schema
- Maps FormField types to edit types

```typescript
"use client";

import { useState, useRef, useEffect } from "react";
import { useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { Pencil } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";
import type { FormField, FieldOption } from "@/types/form-schema";

interface DynamicEditableFieldProps {
  submissionId: Id<"submissions">;
  field: FormField;
  value: unknown;
}

/**
 * Get display value for select/radio fields (lookup label from options)
 */
function getDisplayValue(field: FormField, value: unknown): string {
  if (value === undefined || value === null || value === "") {
    return "";
  }

  // For select/radio, look up option label
  if ((field.type === "select" || field.type === "radio") && field.options) {
    const option = field.options.find((o) => o.value === String(value));
    return option?.label ?? String(value);
  }

  // For checkbox, show Yes/No
  if (field.type === "checkbox") {
    return value ? "Yes" : "No";
  }

  // For file, show "File uploaded" or empty
  if (field.type === "file") {
    return value ? "File uploaded" : "";
  }

  return String(value);
}

/**
 * Map FormField type to edit input type
 */
function getEditType(fieldType: string): "text" | "textarea" | "select" | "date" | "email" | "url" | "number" | "checkbox" {
  switch (fieldType) {
    case "textarea":
      return "textarea";
    case "select":
    case "radio":
      return "select";
    case "date":
      return "date";
    case "email":
      return "email";
    case "url":
      return "url";
    case "number":
      return "number";
    case "checkbox":
      return "checkbox";
    default:
      return "text";
  }
}

export function DynamicEditableField({
  submissionId,
  field,
  value,
}: DynamicEditableFieldProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(String(value ?? ""));
  const [error, setError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const updateField = useMutation(api.submissions.updateField);

  const editType = getEditType(field.type);
  const displayValue = getDisplayValue(field, value);

  // Sync external value when not editing
  useEffect(() => {
    if (!isEditing) {
      setEditValue(String(value ?? ""));
    }
  }, [value, isEditing]);

  // Focus input when entering edit mode
  useEffect(() => {
    if (isEditing) {
      if (editType === "textarea" && textareaRef.current) {
        textareaRef.current.focus();
        textareaRef.current.select();
      } else if (inputRef.current) {
        inputRef.current.focus();
        inputRef.current.select();
      }
    }
  }, [isEditing, editType]);

  const handleSave = async () => {
    if (isSaving) return;

    // Basic validation
    if (field.required && !editValue.trim()) {
      setError("This field is required");
      return;
    }

    setError(null);
    setIsSaving(true);

    try {
      await updateField({
        submissionId,
        fieldId: field.id,
        fieldLabel: field.label, // Store label at edit time
        newValue: editValue,
      });
      setIsEditing(false);
    } catch (e) {
      setError("Failed to save. Please try again.");
      console.error("Failed to update field:", e);
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    setEditValue(String(value ?? ""));
    setError(null);
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Escape") {
      e.preventDefault();
      handleCancel();
    } else if (e.key === "Enter") {
      if (editType === "textarea") {
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          handleSave();
        }
      } else {
        e.preventDefault();
        handleSave();
      }
    }
  };

  const handleBlur = (e: React.FocusEvent) => {
    if (containerRef.current?.contains(e.relatedTarget as Node)) {
      return;
    }
    setTimeout(() => {
      if (isEditing && !isSaving) {
        handleSave();
      }
    }, 100);
  };

  const handleSelectChange = async (newValue: string) => {
    setEditValue(newValue);
    setError(null);
    setIsSaving(true);

    try {
      await updateField({
        submissionId,
        fieldId: field.id,
        fieldLabel: field.label,
        newValue,
      });
      setIsEditing(false);
    } catch (e) {
      setError("Failed to save. Please try again.");
      console.error("Failed to update field:", e);
    } finally {
      setIsSaving(false);
    }
  };

  // File fields are not editable
  if (field.type === "file") {
    return (
      <div className="space-y-1">
        <p className="text-sm font-medium text-muted-foreground">{field.label}</p>
        <p className="text-sm">
          {displayValue || <span className="italic text-muted-foreground">No file</span>}
        </p>
      </div>
    );
  }

  // Checkbox fields - special handling
  if (field.type === "checkbox") {
    return (
      <div className="space-y-1">
        <p className="text-sm font-medium text-muted-foreground">{field.label}</p>
        <p className="text-sm">{value ? "Yes" : "No"}</p>
      </div>
    );
  }

  // Edit mode
  if (isEditing) {
    return (
      <div ref={containerRef} className="space-y-1">
        <p className="text-sm font-medium text-muted-foreground">{field.label}</p>

        {editType === "textarea" ? (
          <Textarea
            ref={textareaRef}
            value={editValue}
            onChange={(e) => setEditValue(e.target.value)}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            disabled={isSaving}
            rows={3}
            className={cn(
              "resize-none ring-2 ring-ring",
              error && "border-destructive ring-destructive/50"
            )}
          />
        ) : editType === "select" && field.options ? (
          <Select
            value={editValue}
            onValueChange={handleSelectChange}
            disabled={isSaving}
          >
            <SelectTrigger
              className={cn(
                "w-full ring-2 ring-ring",
                error && "border-destructive ring-destructive/50"
              )}
            >
              <SelectValue placeholder="Select..." />
            </SelectTrigger>
            <SelectContent>
              {field.options.map((opt) => (
                <SelectItem key={opt.value} value={opt.value}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        ) : (
          <Input
            ref={inputRef}
            type={editType === "number" ? "number" : editType === "date" ? "date" : editType === "email" ? "email" : editType === "url" ? "url" : "text"}
            value={editValue}
            onChange={(e) => setEditValue(e.target.value)}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            disabled={isSaving}
            className={cn(
              "ring-2 ring-ring",
              error && "border-destructive ring-destructive/50"
            )}
          />
        )}

        {error && <p className="text-sm text-destructive">{error}</p>}

        {editType === "textarea" && (
          <p className="text-xs text-muted-foreground">
            Press Ctrl+Enter to save, Escape to cancel
          </p>
        )}
      </div>
    );
  }

  // Display mode
  return (
    <div
      ref={containerRef}
      className="group space-y-1 cursor-pointer rounded-md p-2 -m-2 transition-colors hover:bg-muted/50"
      onClick={() => setIsEditing(true)}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          setIsEditing(true);
        }
      }}
    >
      <p className="text-sm font-medium text-muted-foreground">{field.label}</p>
      <div className="flex items-start gap-2">
        <p className="text-sm whitespace-pre-wrap break-words flex-1">
          {displayValue || (
            <span className="italic text-muted-foreground">Not set</span>
          )}
        </p>
        <Pencil className="h-4 w-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0 mt-0.5" />
      </div>
    </div>
  );
}
```
  </action>
  <verify>
Component compiles without errors. Test in isolation by importing into a test page with mock data. Verify edit mode activates on click, select dropdown shows option labels, save/cancel work.
  </verify>
  <done>
DynamicEditableField renders field based on schema type. Select/radio shows option labels. Edit mode works with save/cancel. Uses api.submissions.updateField with fieldLabel for history.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SubmissionSheet and SubmissionEditHistory</name>
  <files>
    src/components/admin/SubmissionSheet.tsx
    src/components/admin/SubmissionEditHistory.tsx
    src/components/admin/AdminTabs.tsx
  </files>
  <action>
1. Create `src/components/admin/SubmissionEditHistory.tsx`:
   - Simpler than EditHistory - just display stored fieldLabel directly
   - No label lookup needed (stored at edit time)

```typescript
"use client";

import { useState } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { ChevronRight } from "lucide-react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";

interface SubmissionEditHistoryProps {
  submissionId: Id<"submissions">;
}

function truncateValue(value: string, maxLength = 100): string {
  if (value.length <= maxLength) return value;
  return value.slice(0, maxLength) + "...";
}

export function SubmissionEditHistory({ submissionId }: SubmissionEditHistoryProps) {
  const [isOpen, setIsOpen] = useState(false);
  const history = useQuery(api.submissions.getEditHistory, { submissionId });

  if (history === undefined) {
    return null; // Loading
  }

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen}>
      <CollapsibleTrigger className="flex items-center gap-2 w-full text-left font-medium hover:text-foreground/80 transition-colors">
        <ChevronRight
          className={cn(
            "h-4 w-4 transition-transform",
            isOpen && "rotate-90"
          )}
        />
        Edit History
        {history.length > 0 && (
          <span className="text-sm font-normal text-muted-foreground">
            ({history.length})
          </span>
        )}
      </CollapsibleTrigger>
      <CollapsibleContent className="pt-3">
        {history.length === 0 ? (
          <p className="text-sm text-muted-foreground italic">No edits yet</p>
        ) : (
          <div className="space-y-3 border-l-2 border-muted pl-4">
            {history.map((edit) => (
              <div key={edit._id} className="text-sm">
                <p className="font-medium">{edit.fieldLabel}</p>
                <p className="text-muted-foreground">
                  <span className="line-through">
                    {truncateValue(edit.oldValue) || "(empty)"}
                  </span>
                  {" â†’ "}
                  <span>{truncateValue(edit.newValue) || "(empty)"}</span>
                </p>
                <p className="text-xs text-muted-foreground">
                  {new Date(edit.editedAt).toLocaleString()}
                </p>
              </div>
            ))}
          </div>
        )}
      </CollapsibleContent>
    </Collapsible>
  );
}
```

2. Create `src/components/admin/SubmissionSheet.tsx`:
   - Follow ApplicationSheet pattern but iterate over schema
   - Use api.submissions.getWithSchema to get submission + schema together
   - Group fields by step (like DynamicReview)
   - Use DynamicEditableField for each field
   - Include SubmissionStatusDropdown (create inline or reuse StatusDropdown pattern)

```typescript
"use client";

import { useQuery, useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Separator } from "@/components/ui/separator";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { DynamicEditableField } from "./DynamicEditableField";
import { SubmissionEditHistory } from "./SubmissionEditHistory";
import type { FormSchema } from "@/types/form-schema";

interface SubmissionSheetProps {
  submissionId: Id<"submissions"> | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const statusConfig = {
  new: { label: "New", className: "bg-blue-100 text-blue-800 border-blue-200" },
  under_review: { label: "Under Review", className: "bg-yellow-100 text-yellow-800 border-yellow-200" },
  accepted: { label: "Accepted", className: "bg-green-100 text-green-800 border-green-200" },
  rejected: { label: "Rejected", className: "bg-red-100 text-red-800 border-red-200" },
} as const;

function Section({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="space-y-3">
      <h3 className="font-medium">{title}</h3>
      {children}
    </div>
  );
}

function SheetSkeleton() {
  return (
    <div className="space-y-6 px-4 py-4">
      <Skeleton className="h-6 w-48" />
      <Skeleton className="h-4 w-32" />
      <Separator />
      <div className="space-y-4">
        {Array.from({ length: 5 }).map((_, i) => (
          <div key={i} className="space-y-2">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-4 w-full" />
          </div>
        ))}
      </div>
    </div>
  );
}

function SubmissionStatusDropdown({
  submissionId,
  currentStatus,
}: {
  submissionId: Id<"submissions">;
  currentStatus: keyof typeof statusConfig;
}) {
  const updateStatus = useMutation(api.submissions.updateStatus);

  return (
    <Select
      value={currentStatus}
      onValueChange={(status) =>
        updateStatus({
          submissionId,
          status: status as "new" | "under_review" | "accepted" | "rejected",
        })
      }
    >
      <SelectTrigger className="w-[180px]">
        <SelectValue>
          <Badge variant="outline" className={statusConfig[currentStatus].className}>
            {statusConfig[currentStatus].label}
          </Badge>
        </SelectValue>
      </SelectTrigger>
      <SelectContent>
        {Object.entries(statusConfig).map(([value, config]) => (
          <SelectItem key={value} value={value}>
            <Badge variant="outline" className={config.className}>
              {config.label}
            </Badge>
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}

export function SubmissionSheet({
  submissionId,
  open,
  onOpenChange,
}: SubmissionSheetProps) {
  const result = useQuery(
    api.submissions.getWithSchema,
    submissionId ? { submissionId } : "skip"
  );

  if (!submissionId) {
    return (
      <Sheet open={open} onOpenChange={onOpenChange}>
        <SheetContent className="overflow-y-auto" />
      </Sheet>
    );
  }

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent className="w-full sm:w-[540px] sm:max-w-[calc(100vw-2rem)] overflow-y-auto">
        {result === undefined ? (
          <SheetSkeleton />
        ) : result === null ? (
          <div className="p-4">
            <p className="text-muted-foreground">Submission not found</p>
          </div>
        ) : (
          <>
            <SheetHeader>
              <SheetTitle className="break-words pr-8">
                {result.formName}
              </SheetTitle>
              <SheetDescription className="break-words">
                Version {result.version} - Submitted{" "}
                {new Date(result.submission.submittedAt).toLocaleDateString()}
              </SheetDescription>
            </SheetHeader>

            <div className="space-y-6 px-4 py-4">
              {/* Status */}
              <Section title="Status">
                <SubmissionStatusDropdown
                  submissionId={submissionId}
                  currentStatus={result.submission.status}
                />
              </Section>

              <Separator />

              {/* Dynamic fields by step */}
              {(result.schema as FormSchema).steps.map((step) => (
                <div key={step.id}>
                  <Section title={step.title}>
                    <div className="space-y-3">
                      {step.fields.map((field) => (
                        <DynamicEditableField
                          key={field.id}
                          submissionId={submissionId}
                          field={field}
                          value={result.submission.data[field.id]}
                        />
                      ))}
                    </div>
                  </Section>
                  <Separator className="mt-6" />
                </div>
              ))}

              {/* Edit History */}
              <SubmissionEditHistory submissionId={submissionId} />

              <Separator />

              {/* Footer */}
              <p className="text-sm text-muted-foreground">
                Submitted on{" "}
                {new Date(result.submission.submittedAt).toLocaleDateString("en-US", {
                  year: "numeric",
                  month: "long",
                  day: "numeric",
                  hour: "numeric",
                  minute: "2-digit",
                })}
              </p>
            </div>
          </>
        )}
      </SheetContent>
    </Sheet>
  );
}
```

3. Update `src/components/admin/AdminTabs.tsx`:
   - Import SubmissionSheet
   - Add SubmissionSheet component below SubmissionsTable
   - Pass selectedSubmission._id to sheet

```typescript
// In AdminTabs, update submissions tab content:
<TabsContent value="submissions">
  <SubmissionsTable onRowClick={handleSubmissionClick} />
  <SubmissionSheet
    submissionId={selectedSubmission?._id ?? null}
    open={submissionSheetOpen}
    onOpenChange={setSubmissionSheetOpen}
  />
</TabsContent>
```
  </action>
  <verify>
Navigate to /admin?tab=submissions. Click a submission row - sheet should open with all form fields. Edit a field - should save and show in edit history. Status dropdown should change submission status.
  </verify>
  <done>
SubmissionSheet opens on row click showing all fields by step. Fields are editable via DynamicEditableField. Select fields show option labels. Edit history shows field labels. Status can be changed.
  </done>
</task>

</tasks>

<verification>
1. Navigate to /admin?tab=submissions
2. Click a submission row - sheet opens
3. Sheet shows form name, version, submission date
4. Fields grouped by step from schema
5. Click a field - edit mode activates
6. Select/radio fields show option labels (not raw values)
7. Save an edit - check it appears in edit history
8. Edit history shows correct field label
9. Status dropdown changes submission status
10. Sheet closes cleanly
</verification>

<success_criteria>
- SubmissionSheet renders fields dynamically from schema
- DynamicEditableField handles all field types
- Select/radio options display labels
- Edit history uses stored fieldLabel (not lookup)
- Status dropdown updates submission status
- Full inline editing flow works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/15-admin-integration/15-03-SUMMARY.md`
</output>
