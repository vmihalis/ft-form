---
phase: 18-export
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/components/admin/ExportButton.tsx
  - src/components/admin/SubmissionsFilters.tsx
  - src/components/admin/SubmissionsTable.tsx
  - convex/submissions.ts
autonomous: true

must_haves:
  truths:
    - "Admin can click export button and download CSV file"
    - "CSV contains all submission fields with human-readable column headers"
    - "Export respects active filters (only filtered submissions are exported)"
    - "CSV opens correctly in Excel with proper encoding"
  artifacts:
    - path: "src/components/admin/ExportButton.tsx"
      provides: "Export button component with loading state"
      exports: ["ExportButton"]
    - path: "convex/submissions.ts"
      provides: "Query to fetch submissions with schema data for export"
      exports: ["listForExport"]
  key_links:
    - from: "src/components/admin/ExportButton.tsx"
      to: "src/lib/csv-export.ts"
      via: "function import"
      pattern: "import.*generateCSV.*downloadCSV"
    - from: "src/components/admin/ExportButton.tsx"
      to: "convex/submissions.ts"
      via: "Convex query"
      pattern: "api.submissions.listForExport"
    - from: "src/components/admin/SubmissionsTable.tsx"
      to: "src/components/admin/ExportButton.tsx"
      via: "component composition"
      pattern: "<ExportButton"
---

<objective>
Add CSV export button that exports filtered submissions with schema-driven column headers.

Purpose: Complete EXPORT-01 (download CSV) and EXPORT-02 (export respects filters). The admin can now export exactly what they see in the filtered table view.

Output: Working export button that generates CSV with field labels as headers, respecting all active filters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-export/18-RESEARCH.md
@.planning/phases/18-export/18-01-PLAN.md

@src/lib/csv-export.ts
@src/components/admin/SubmissionsTable.tsx
@src/components/admin/SubmissionsFilters.tsx
@src/components/admin/submissions-columns.tsx
@src/types/form-schema.ts
@convex/submissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Convex query for export data</name>
  <files>convex/submissions.ts</files>
  <action>
Add a new query `listForExport` to convex/submissions.ts that returns full submission data with schema.

This query differs from `list` because:
- It includes full submission data (not just metadata)
- It includes the schema for building CSV headers
- It's optimized for batch export (single call returns everything needed)

Add this query after the existing `list` query:

```typescript
/**
 * List submissions with full data and schema for CSV export
 * Returns all data needed to generate human-readable CSV
 */
export const listForExport = query({
  args: {
    submissionIds: v.array(v.id("submissions")),
  },
  handler: async (ctx, args) => {
    if (args.submissionIds.length === 0) {
      return { submissions: [], schema: null };
    }

    // Fetch all submissions
    const submissions = await Promise.all(
      args.submissionIds.map((id) => ctx.db.get(id))
    );

    // Filter out any nulls (shouldn't happen but defensive)
    const validSubmissions = submissions.filter(
      (s): s is NonNullable<typeof s> => s !== null
    );

    if (validSubmissions.length === 0) {
      return { submissions: [], schema: null };
    }

    // Get schema from first submission's version
    // All filtered submissions should be from same form due to form filter
    const firstVersion = await ctx.db.get(validSubmissions[0].formVersionId);
    const form = firstVersion ? await ctx.db.get(firstVersion.formId) : null;

    return {
      submissions: validSubmissions.map((s) => ({
        _id: s._id,
        status: s.status,
        submittedAt: s.submittedAt,
        data: JSON.parse(s.data) as Record<string, unknown>,
      })),
      schema: firstVersion ? JSON.parse(firstVersion.schema) : null,
      formName: form?.name ?? "submissions",
    };
  },
});
```

Note: This query takes submission IDs (from filtered table rows) rather than re-filtering on the server. This ensures export matches exactly what the user sees.
  </action>
  <verify>
1. `npx convex dev` runs without errors (types regenerate)
2. `npx tsc --noEmit` passes
  </verify>
  <done>listForExport query added to convex/submissions.ts, returns submissions with parsed data and schema</done>
</task>

<task type="auto">
  <name>Task 2: Create ExportButton component</name>
  <files>src/components/admin/ExportButton.tsx</files>
  <action>
Create `src/components/admin/ExportButton.tsx` that handles the export logic.

Component responsibilities:
- Shows download icon button
- On click, fetches full data for provided submission IDs
- Builds CSV with schema-driven headers
- Triggers download with formatted filename

```typescript
"use client";

import { useState } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Download, Loader2 } from "lucide-react";
import { generateCSV, downloadCSV } from "@/lib/csv-export";
import type { FormSchema } from "@/types/form-schema";

interface ExportButtonProps {
  submissionIds: Id<"submissions">[];
  disabled?: boolean;
}

export function ExportButton({ submissionIds, disabled }: ExportButtonProps) {
  const [isExporting, setIsExporting] = useState(false);

  // Query is skipped until export is triggered, then uses the IDs
  const exportData = useQuery(
    api.submissions.listForExport,
    isExporting && submissionIds.length > 0 ? { submissionIds } : "skip"
  );

  const handleExport = async () => {
    if (submissionIds.length === 0) return;
    setIsExporting(true);
  };

  // Effect: when data loads, generate and download CSV
  if (isExporting && exportData && exportData.submissions.length > 0) {
    const { submissions, schema, formName } = exportData;
    const parsedSchema = schema as FormSchema | null;

    // Build headers from schema
    const headers: { key: string; label: string }[] = [
      { key: "_status", label: "Status" },
      { key: "_submittedAt", label: "Submitted Date" },
    ];

    if (parsedSchema) {
      parsedSchema.steps.forEach((step) => {
        step.fields.forEach((field) => {
          headers.push({ key: field.id, label: field.label });
        });
      });
    }

    // Build data rows
    const data = submissions.map((sub) => ({
      _status: formatStatus(sub.status),
      _submittedAt: new Date(sub.submittedAt).toISOString().split("T")[0],
      ...sub.data,
    }));

    // Generate and download
    const csv = generateCSV(data, headers);
    const filename = `${formName.toLowerCase().replace(/\s+/g, "-")}-export-${new Date().toISOString().split("T")[0]}.csv`;
    downloadCSV(csv, filename);

    // Reset state
    setIsExporting(false);
  }

  // Handle empty state after export triggered
  if (isExporting && exportData && exportData.submissions.length === 0) {
    setIsExporting(false);
  }

  const isLoading = isExporting && !exportData;

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={handleExport}
      disabled={disabled || submissionIds.length === 0 || isLoading}
      title={submissionIds.length === 0 ? "No submissions to export" : `Export ${submissionIds.length} submissions`}
    >
      {isLoading ? (
        <Loader2 className="h-4 w-4 animate-spin" />
      ) : (
        <Download className="h-4 w-4" />
      )}
      <span className="ml-2">Export CSV</span>
    </Button>
  );
}

function formatStatus(status: string): string {
  const statusLabels: Record<string, string> = {
    new: "New",
    under_review: "Under Review",
    accepted: "Accepted",
    rejected: "Rejected",
  };
  return statusLabels[status] || status;
}
```

Key design decisions:
- Uses conditional query (skipped until export clicked) to avoid unnecessary data fetching
- Builds headers from schema so column names are human-readable field labels
- Filename includes form name and date for organization
- Shows loading state while fetching
- Disabled when no submissions to export
  </action>
  <verify>
1. File exists: `ls src/components/admin/ExportButton.tsx`
2. `npx tsc --noEmit` passes
  </verify>
  <done>ExportButton.tsx created with query-based export, schema-driven headers, and loading state</done>
</task>

<task type="auto">
  <name>Task 3: Wire export button into SubmissionsTable</name>
  <files>
    src/components/admin/SubmissionsFilters.tsx
    src/components/admin/SubmissionsTable.tsx
  </files>
  <action>
Update SubmissionsFilters and SubmissionsTable to include the export button.

**SubmissionsFilters.tsx changes:**
Add export button as the last item in the filter bar.

1. Add new props:
```typescript
interface SubmissionsFiltersProps {
  // ... existing props ...
  filteredCount: number;
  filteredIds: string[];
  onExport?: () => void;
}
```

2. Import and render ExportButton at the end of the flex container:
```typescript
import { ExportButton } from "./ExportButton";
import { Id } from "../../../convex/_generated/dataModel";

// In component:
<div className="flex flex-wrap gap-4 items-center">
  {/* existing filters */}
  <FormFilter ... />
  <StatusFilter ... />
  <DateRangeFilter ... />
  <SearchInput ... />

  {/* Spacer to push export right */}
  <div className="flex-1" />

  {/* Export button */}
  <ExportButton
    submissionIds={filteredIds as Id<"submissions">[]}
  />
</div>
```

3. Add count display showing filtered vs total:
```typescript
<span className="text-sm text-muted-foreground whitespace-nowrap">
  {filteredCount} submission{filteredCount !== 1 ? "s" : ""}
</span>
```

**SubmissionsTable.tsx changes:**

1. Pass filtered row IDs to SubmissionsFilters:
```typescript
// Get filtered row IDs for export
const filteredRows = table.getFilteredRowModel().rows;
const filteredIds = filteredRows.map((row) => row.original._id);

<SubmissionsFilters
  // ... existing props ...
  filteredCount={filteredRows.length}
  filteredIds={filteredIds}
/>
```

2. Ensure `getFilteredRowModel` is imported (should already be from Task 1 integration)
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Run `npm run dev` and verify at /admin:
   - Export button appears in filter bar
   - Button shows count (e.g., "Export CSV")
   - Clicking export downloads a CSV file
   - CSV opens in Excel/spreadsheet with correct columns
   - Apply filters, export again - only filtered submissions in CSV
  </verify>
  <done>Export button integrated into SubmissionsTable, exports filtered submissions with schema-driven headers</done>
</task>

</tasks>

<verification>
1. `npm run build` completes successfully
2. Export button visible in admin submissions view
3. Clicking export with no filters downloads all submissions
4. Applying status filter (e.g., "Accepted") then export downloads only accepted submissions
5. Applying date range filter then export downloads only submissions in range
6. Combining filters (status + date + form) exports correct subset
7. CSV file:
   - Opens correctly in Excel
   - Has human-readable column headers (field labels, not IDs)
   - Contains Status and Submitted Date columns
   - Contains all form field columns
   - Special characters (commas, quotes) are properly escaped
8. No TypeScript errors
9. No console errors at runtime
</verification>

<success_criteria>
- EXPORT-01 complete: Admin can download all submissions for a form as CSV
- EXPORT-02 complete: Admin can filter by status and date range before exporting
- CSV has human-readable headers derived from form schema
- Export button shows loading state during fetch
- Export respects all active filters (form, status, date range, search)
- File downloads with descriptive filename (form-name-export-YYYY-MM-DD.csv)
</success_criteria>

<output>
After completion, create `.planning/phases/18-export/18-02-SUMMARY.md`
</output>
