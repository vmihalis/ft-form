---
phase: 13-dynamic-form-renderer
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/components/dynamic-form/fields/TextField.tsx
  - src/components/dynamic-form/fields/TextareaField.tsx
  - src/components/dynamic-form/fields/EmailField.tsx
  - src/components/dynamic-form/fields/NumberField.tsx
  - src/components/dynamic-form/fields/DateField.tsx
  - src/components/dynamic-form/fields/SelectField.tsx
  - src/components/dynamic-form/fields/CheckboxField.tsx
  - src/components/dynamic-form/fields/FileUploadField.tsx
  - src/components/dynamic-form/fields/index.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Text fields render with label, placeholder, and help text"
    - "Email fields validate email format on blur/submit"
    - "Select fields show dropdown with configured options"
    - "Checkbox fields toggle boolean value"
    - "File fields upload immediately on selection"
    - "All fields show validation errors from react-hook-form"
  artifacts:
    - path: "src/components/dynamic-form/fields/TextField.tsx"
      provides: "Text input field renderer"
      min_lines: 20
    - path: "src/components/dynamic-form/fields/SelectField.tsx"
      provides: "Dropdown select field renderer"
      min_lines: 30
    - path: "src/components/dynamic-form/fields/CheckboxField.tsx"
      provides: "Checkbox field renderer"
      min_lines: 20
    - path: "src/components/dynamic-form/fields/FileUploadField.tsx"
      provides: "File upload field with immediate persistence"
      min_lines: 20
    - path: "src/components/dynamic-form/fields/index.tsx"
      provides: "Field type router component"
      exports: ["DynamicField"]
  key_links:
    - from: "src/components/dynamic-form/fields/index.tsx"
      to: "src/types/form-schema.ts"
      via: "FormField and FieldType imports"
      pattern: "import.*FieldType.*form-schema"
    - from: "src/components/dynamic-form/fields/FileUploadField.tsx"
      to: "src/components/form/fields/FileField.tsx"
      via: "FileField component reuse"
      pattern: "import.*FileField"
---

<objective>
Create field renderer components for all dynamic form field types

Purpose: Enable schema-driven field rendering with proper validation integration
Output: Complete set of field components + DynamicField router
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-dynamic-form-renderer/13-RESEARCH.md

# Plan 01 outputs
@src/lib/schemas/dynamic-form.ts

# Existing components to reuse
@src/components/ui/field.tsx
@src/components/ui/input.tsx
@src/components/ui/textarea.tsx
@src/components/ui/select.tsx
@src/components/form/fields/FileField.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create text, textarea, email, number, and date field renderers</name>
  <files>
    - src/components/dynamic-form/fields/TextField.tsx
    - src/components/dynamic-form/fields/TextareaField.tsx
    - src/components/dynamic-form/fields/EmailField.tsx
    - src/components/dynamic-form/fields/NumberField.tsx
    - src/components/dynamic-form/fields/DateField.tsx
  </files>
  <action>
Create field renderer components following this pattern. Each component receives a FormField from the schema.

All field components should:
- Use "use client" directive
- Import useFormContext from react-hook-form
- Import Field, FieldLabel, FieldDescription, FieldError from @/components/ui/field
- Import Input (or Textarea) from @/components/ui
- Get register and formState.errors from useFormContext
- Extract error message: `errors[field.id]?.message as string | undefined`
- Render Field wrapper with data-invalid={!!error}
- Show "(optional)" suffix on label if !field.required
- Show FieldDescription if field.description exists
- Show FieldError with error message

TextField.tsx:
```typescript
"use client";

import { useFormContext } from "react-hook-form";
import { Field, FieldLabel, FieldDescription, FieldError } from "@/components/ui/field";
import { Input } from "@/components/ui/input";
import type { FormField } from "@/types/form-schema";

interface TextFieldProps {
  field: FormField;
}

export function TextField({ field }: TextFieldProps) {
  const { register, formState: { errors } } = useFormContext();
  const error = errors[field.id]?.message as string | undefined;

  return (
    <Field data-invalid={!!error}>
      <FieldLabel htmlFor={field.id}>
        {field.label}
        {!field.required && (
          <span className="text-muted-foreground font-normal"> (optional)</span>
        )}
      </FieldLabel>
      <Input
        id={field.id}
        type="text"
        {...register(field.id)}
        placeholder={field.placeholder}
        aria-invalid={!!error}
      />
      {field.description && <FieldDescription>{field.description}</FieldDescription>}
      <FieldError>{error}</FieldError>
    </Field>
  );
}
```

TextareaField.tsx:
- Same pattern but use Textarea component
- Import Textarea from @/components/ui/textarea

EmailField.tsx:
- Same pattern as TextField but type="email"

NumberField.tsx:
- Same pattern as TextField but type="number"
- Add step="any" to allow decimals
- Add min/max if field.validation has them

DateField.tsx:
- Same pattern as TextField but type="date"
  </action>
  <verify>
- `ls src/components/dynamic-form/fields/TextField.tsx` exists
- `grep "register" src/components/dynamic-form/fields/TextField.tsx` shows react-hook-form integration
- `ls src/components/dynamic-form/fields/DateField.tsx` exists
  </verify>
  <done>
- Text, textarea, email, number, date field components created
- All integrate with react-hook-form via useFormContext
- All show validation errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create select, checkbox, and file field renderers</name>
  <files>
    - src/components/dynamic-form/fields/SelectField.tsx
    - src/components/dynamic-form/fields/CheckboxField.tsx
    - src/components/dynamic-form/fields/FileUploadField.tsx
  </files>
  <action>
Create more complex field renderers:

SelectField.tsx:
- Use Controller from react-hook-form (Radix Select needs controlled component)
- Import Controller, useFormContext from react-hook-form
- Import Select, SelectTrigger, SelectValue, SelectContent, SelectItem from @/components/ui/select
- Import Field, FieldLabel, FieldDescription, FieldError from @/components/ui/field
- Use Controller with name={field.id} and control from useFormContext
- In render prop: <Select onValueChange={rhfField.onChange} value={rhfField.value || ""}>
- Map field.options to SelectItem components
- Handle empty options array gracefully (show disabled message)

```typescript
"use client";

import { Controller, useFormContext } from "react-hook-form";
import { Field, FieldLabel, FieldDescription, FieldError } from "@/components/ui/field";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { FormField } from "@/types/form-schema";

interface SelectFieldProps {
  field: FormField;
}

export function SelectField({ field }: SelectFieldProps) {
  const { control, formState: { errors } } = useFormContext();
  const error = errors[field.id]?.message as string | undefined;

  return (
    <Field data-invalid={!!error}>
      <FieldLabel htmlFor={field.id}>
        {field.label}
        {!field.required && (
          <span className="text-muted-foreground font-normal"> (optional)</span>
        )}
      </FieldLabel>
      <Controller
        name={field.id}
        control={control}
        render={({ field: rhfField }) => (
          <Select onValueChange={rhfField.onChange} value={rhfField.value || ""}>
            <SelectTrigger id={field.id} className="w-full" aria-invalid={!!error}>
              <SelectValue placeholder={field.placeholder || "Select an option"} />
            </SelectTrigger>
            <SelectContent>
              {field.options?.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      />
      {field.description && <FieldDescription>{field.description}</FieldDescription>}
      <FieldError>{error}</FieldError>
    </Field>
  );
}
```

CheckboxField.tsx:
- Use native checkbox input styled with Tailwind
- Use Controller for controlled checkbox
- Render as inline-flex with checkbox and label text side by side
- Checkbox styling: `h-5 w-5 rounded border-input accent-primary`

```typescript
"use client";

import { Controller, useFormContext } from "react-hook-form";
import { Field, FieldDescription, FieldError } from "@/components/ui/field";
import type { FormField } from "@/types/form-schema";

interface CheckboxFieldProps {
  field: FormField;
}

export function CheckboxField({ field }: CheckboxFieldProps) {
  const { control, formState: { errors } } = useFormContext();
  const error = errors[field.id]?.message as string | undefined;

  return (
    <Field data-invalid={!!error}>
      <Controller
        name={field.id}
        control={control}
        render={({ field: rhfField }) => (
          <label className="flex items-start gap-3 cursor-pointer">
            <input
              type="checkbox"
              id={field.id}
              checked={rhfField.value || false}
              onChange={(e) => rhfField.onChange(e.target.checked)}
              className="mt-0.5 h-5 w-5 rounded border-input accent-primary"
              aria-invalid={!!error}
            />
            <span className="text-sm">
              {field.label}
              {!field.required && (
                <span className="text-muted-foreground"> (optional)</span>
              )}
            </span>
          </label>
        )}
      />
      {field.description && <FieldDescription>{field.description}</FieldDescription>}
      <FieldError>{error}</FieldError>
    </Field>
  );
}
```

FileUploadField.tsx:
- Use Controller to wrap existing FileField component
- Import FileField from @/components/form/fields/FileField
- Import Id type from convex/_generated/dataModel for type safety
- Pass value and onChange to FileField
- FileField already handles its own label/description display

```typescript
"use client";

import { Controller, useFormContext } from "react-hook-form";
import { Field, FieldError } from "@/components/ui/field";
import { FileField } from "@/components/form/fields/FileField";
import type { FormField } from "@/types/form-schema";
import type { Id } from "../../../../convex/_generated/dataModel";

interface FileUploadFieldProps {
  field: FormField;
}

export function FileUploadField({ field }: FileUploadFieldProps) {
  const { control, formState: { errors } } = useFormContext();
  const error = errors[field.id]?.message as string | undefined;

  return (
    <Field data-invalid={!!error}>
      <Controller
        name={field.id}
        control={control}
        render={({ field: rhfField }) => (
          <FileField
            value={rhfField.value as Id<"_storage"> | null}
            onChange={rhfField.onChange}
            label={field.label + (!field.required ? " (optional)" : "")}
            description={field.description}
          />
        )}
      />
      <FieldError>{error}</FieldError>
    </Field>
  );
}
```
  </action>
  <verify>
- `grep "Controller" src/components/dynamic-form/fields/SelectField.tsx` shows controlled component
- `grep "FileField" src/components/dynamic-form/fields/FileUploadField.tsx` shows reuse
- `grep "checkbox" src/components/dynamic-form/fields/CheckboxField.tsx` shows checkbox input
  </verify>
  <done>
- Select field with Radix UI dropdown
- Checkbox field with native styled input
- File field wrapping existing FileField component
  </done>
</task>

<task type="auto">
  <name>Task 3: Create field type router component</name>
  <files>src/components/dynamic-form/fields/index.tsx</files>
  <action>
Create the DynamicField component that routes to the appropriate field renderer based on field.type:

```typescript
"use client";

import type { FormField, FieldType } from "@/types/form-schema";
import { TextField } from "./TextField";
import { TextareaField } from "./TextareaField";
import { EmailField } from "./EmailField";
import { NumberField } from "./NumberField";
import { DateField } from "./DateField";
import { SelectField } from "./SelectField";
import { CheckboxField } from "./CheckboxField";
import { FileUploadField } from "./FileUploadField";

interface DynamicFieldProps {
  field: FormField;
}

export function DynamicField({ field }: DynamicFieldProps) {
  switch (field.type) {
    case "text":
      return <TextField field={field} />;
    case "url":
      return <TextField field={field} />;
    case "email":
      return <EmailField field={field} />;
    case "textarea":
      return <TextareaField field={field} />;
    case "number":
      return <NumberField field={field} />;
    case "date":
      return <DateField field={field} />;
    case "select":
      return <SelectField field={field} />;
    case "radio":
      // Radio renders same as select for now (can enhance later)
      return <SelectField field={field} />;
    case "checkbox":
      return <CheckboxField field={field} />;
    case "file":
      return <FileUploadField field={field} />;
    default:
      // Fallback to text field for unknown types
      return <TextField field={field} />;
  }
}
```

NOTE: URL fields use TextField with type="text" because browser URL validation is too strict (requires protocol). Zod schema handles URL validation if pattern is set.

NOTE: Radio fields fall back to SelectField for now. A dedicated RadioField can be added in a future enhancement if needed.
  </action>
  <verify>
- `grep "DynamicField" src/components/dynamic-form/fields/index.tsx` shows export
- `grep "switch.*field.type" src/components/dynamic-form/fields/index.tsx` shows router logic
  </verify>
  <done>
- DynamicField component routes to correct renderer
- All 10 field types handled (text, url, email, textarea, number, date, select, radio, checkbox, file)
- Unknown types fallback to text field
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `npm run build` - should compile without TypeScript errors
2. All field components exist in src/components/dynamic-form/fields/
3. DynamicField can be imported and used: `import { DynamicField } from "@/components/dynamic-form/fields"`
</verification>

<success_criteria>
- All field type components created and export correctly
- Each field integrates with react-hook-form context
- Each field shows validation errors
- DynamicField router handles all FieldType values
- FileUploadField reuses existing FileField component
</success_criteria>

<output>
After completion, create `.planning/phases/13-dynamic-form-renderer/13-02-SUMMARY.md`
</output>
